<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>PyForks.trailforks_region API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>PyForks.trailforks_region</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import pandas as pd
import requests
import re
import io
import calendar
import tempfile
from bs4 import BeautifulSoup
from tqdm import tqdm
from concurrent.futures import as_completed, ThreadPoolExecutor
from PyForks.trailforks import Trailforks, authentication

class TrailforksRegion(Trailforks):

    def is_valid_region(self, region: str) -&gt; bool:
        &#34;&#34;&#34;
        Check to make sure a region name is a real region by
        making sure the page title is not Error

        Returns:
            bool: True:is an existing region;False:region does not exist.
        &#34;&#34;&#34;
        uri = f&#34;https://www.trailforks.com/region/{region}&#34;
        r = requests.get(uri)
        non_existent = &#34;&lt;title&gt;Error&lt;/title&gt;&#34;
        if non_existent in r.text:
            return False
        return True

    def check_region(self, region: str) -&gt; bool:
        &#34;&#34;&#34;
        A wrapper function for is_valid_region() that conducts an
        exit if the region is non-existant.

        Returns:
            bool: True: Region is valid
        &#34;&#34;&#34;
        if not self.is_valid_region(region):
            print(f&#34;[!] {region} is not a valid Trailforks Region.&#34;)
            exit(1)
        return True

    def __enrich_ridecounts(self, df: pd.DataFrame) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Takes in a Pandas Dataframe with messy data from Trailforks
        and cleans it up, adds values, and simply just normalizes it

        Args:
            df (pd.DataFrame): Raw Trailforks Data

        Returns:
            pd.DataFrame: Clean and Encriched Trailforks Data
        &#34;&#34;&#34;
        df[&#34;date&#34;] = pd.to_datetime(df[&#34;date&#34;])
        df[&#34;year&#34;] = df[&#34;date&#34;].dt.year
        df[&#39;month&#39;] = df[&#34;date&#34;].dt.month
        df[&#39;day&#39;] = df[&#34;date&#34;].dt.day
        df[&#39;weekday_num&#39;] = df[&#39;date&#39;].dt.weekday
        df[&#39;weekday&#39;] = df[&#34;date&#34;].dt.day_name()
        df[&#39;month_name&#39;] = df[&#39;month&#39;].apply(lambda x: calendar.month_abbr[x])

        return df

    @authentication
    def download_region_ridecounts(self, region: str) -&gt; bool:
        &#34;&#34;&#34;
        Downloads a regions total ridecounts is CSV format. Ideally, this should 
        be handled by the Trailforks API but, they&#39;ve not provisioning access 
        at this point (https://www.trailforks.com/about/api/)

        Args:
            region (str): Trailforks region name per URI
            output_path (str, optional): Where to store CSV Defaults to &#34;.&#34;.

        Returns:
            bool: true:CSV written to disk;False:failed to write CSV
        &#34;&#34;&#34;
        success = False
        self.check_region(region)
        uri = f&#34;https://www.trailforks.com/region/{region}/ridelogcountscsv/&#34;
        r = self.trailforks_session.get(uri, allow_redirects=True)
        raw_csv_data = r.text
        
        if &#34;date,rides&#34; in raw_csv_data:
            raw_df = pd.read_csv(io.StringIO(raw_csv_data))
            raw_df[&#34;region&#34;] = region
            return self.__enrich_ridecounts(raw_df)

        else:
            if self._check_requires_region_admin(r.text):
                print(f&#34;[!] Error: You need to be an Admin for {region} to download Trail Ridecounts&#34;)
            return pd.DataFrame

    def __clean_region_trails(self, df: pd.DataFrame) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Clean the region traillog data by converting distance data into 
        a useable metric (miles).

        Args:
            df (pd.DataFrame): _description_

        Returns:
            pd.DataFrame: _description_
        &#34;&#34;&#34;

        df[&#39;total_miles&#39;] = None
        df[&#39;descent_miles&#39;] = None
        df[&#39;ascent_miles&#39;] = None
        df[&#39;flat_miles&#39;] = None
        for index, row in df.iterrows():
            df.loc[index, &#39;total_miles&#39;] = self.feet_to_miles(str(row[&#39;distance&#39;]))
            df.loc[index, &#39;descent_miles&#39;] = self.feet_to_miles(str(row[&#39;dst_descent&#39;]))
            df.loc[index, &#39;ascent_miles&#39;] = self.feet_to_miles(str(row[&#39;dst_climb&#39;]))
            df.loc[index, &#39;flat_miles&#39;] = self.feet_to_miles(str(row[&#39;dst_flat&#39;]))
        df[&#39;total_miles&#39;] = df[&#39;total_miles&#39;].astype(float)
        df[&#39;descent_miles&#39;] = df[&#39;descent_miles&#39;].astype(float)
        df[&#39;ascent_miles&#39;] = df[&#39;ascent_miles&#39;].astype(float)
        df[&#39;flat_miles&#39;] = df[&#39;flat_miles&#39;].astype(float)

        return df

    def __clean_raw_csv_data(self, raw_data: str) -&gt; str:
        &#34;&#34;&#34;
        Trailforks CSV data is pretty bad in terms of quality. We
        need to clean things up quite a bit to get it into a dataframe

        Args:
            raw_data (str): raw CSV data

        Returns:
            str: cleaned csv data
        &#34;&#34;&#34;
        fix_csv_data = re.sub(r&#39;\nhttps&#39;, &#34;\&#34;,\&#34;https&#34;, raw_data)
        csv_data_list = []
        for line in fix_csv_data.split(&#34;\n&#34;):
            line = line.strip()                     # remove un-needed chars

            if &#34;title&#34; not in line:
                line = line[:-1]

            csv_data_list.append(line)

        return &#34;\n&#34;.join(csv_data_list)
        

    @authentication
    def download_all_region_trails(self, region: str, region_id: str) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Each region has a CSV export capability to export all trails within the region.
        This function automates that export for the end user and saves a csv to local
        disk. Ideally, this should be handled by the Trailforks API but,
        they&#39;ve not provisioning access at this point (https://www.trailforks.com/about/api/)

        Args:
            region (str): region name as is shows on a URI
            region_id (str): this is the integer (string representation) of the region
            output_path (str, optional): output directory for the CSV. Defaults to &#34;.&#34;.

        Returns:
            DataFrame: Pandas DataFrame
        &#34;&#34;&#34;
        success = False
        self.check_region(region)
        uri = f&#34;https://www.trailforks.com/tools/trailspreadsheet_csv/?cols=title,difficulty,region_title,distance,dst_climb,dst_descent,dst_flat&amp;rid={region_id}&#34;
        r = self.trailforks_session.get(uri, allow_redirects=True)
        raw_csv_data = r.text
        clean_csv_data = self.__clean_raw_csv_data(raw_csv_data)

        if &#34;title,difficulty&#34; in clean_csv_data:
            df = pd.read_csv(io.StringIO(clean_csv_data))
            return self.__clean_region_trails(df)
            #return df

        else:
            if self._check_requires_region_admin(r.text):
                print(f&#34;[!] Error: You need to be an Admin for {region} to download Trail Data&#34;)
            return pd.DataFrame()

    def __clean_ridelogs(self, df: pd.DataFrame) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Region ridelogs are messy AF! We need to normalize the distances and climb
        data for it to be useful. We will also re-name the dist and climb columns
        to denote their metric type (e.g., miles, feet, etc.)

        Args:
            df (pd.DataFrame): raw Data from Trailforks

        Returns:
            pd.DataFrame: Normalized Trailforks data
        &#34;&#34;&#34;
        date_rex = re.compile(r&#39;^\d{2,4}-\d{1,2}-\d{1,2}\s&#39;)
        try:
            df = df.rename(columns={&#34;dist&#34;: &#34;dist_miles&#34;, &#34;climb&#34;: &#34;climb_miles&#34;, &#34;created&#34;: &#34;date&#34;})
            for index, row in df.iterrows():
                df.loc[index, &#39;dist_miles&#39;] = self.distance_string_to_miles_float(str(row[&#39;dist_miles&#39;]))
                df.loc[index, &#39;climb_miles&#39;] = self.distance_string_to_miles_float(str(row[&#39;climb_miles&#39;]))
                df.loc[index, &#39;date&#39;] = date_rex.findall(row[&#39;date&#39;])[0]

            df[&#39;dist_miles&#39;] = df[&#39;dist_miles&#39;].astype(float)       # miles as float
            df[&#39;climb_miles&#39;] = df[&#39;climb_miles&#39;].astype(float)     # miles as float
            df[&#34;date&#34;] = pd.to_datetime(df[&#34;date&#34;])                 # cast to datetime
            df[&#34;year&#34;] = df[&#34;date&#34;].dt.year                         # get the year (int)
            df[&#39;month&#39;] = df[&#34;date&#34;].dt.month                       # get the month (int)
            df[&#39;day&#39;] = df[&#34;date&#34;].dt.day                           # get the day (int)
            df[&#39;weekday_num&#39;] = df[&#39;date&#39;].dt.weekday               # get the weekday (int)
            df[&#39;weekday&#39;] = df[&#34;date&#34;].dt.day_name()                # get the weekday (str)
            df[&#39;month_name&#39;] = df[&#39;month&#39;].apply(lambda x: calendar.month_abbr[x])
            df = df.loc[:, ~df.columns.str.contains(&#39;^Unnamed&#39;)]    # Drop unnamed columns
            df.fillna(&#34;unknown&#34;, inplace=True)

            return df
        except Exception as e:
            print(f&#34;[!!] ERROR {e}&#34;)
            return pd.DataFrame

    @authentication
    def download_all_region_ridelogs(self, region: str) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Downloads all of the trail ridelogs since the begining of the 
        trails existance and stores the results in CSV format on the 
        local disk. Ideally, this should be handled by the Trailforks API but,
        they&#39;ve not provisioning access at this point (https://www.trailforks.com/about/api)

        Args:
            region (str): region name as is shows on a URI
            output_path (str, optional): Path to store csv. Defaults to &#34;.&#34;.
            
        Returns:
            bool: Pandas DataFrame
        &#34;&#34;&#34;
        self.check_region(region)
        region_info = self._get_region_info(region)
        total_pages = round(region_info[&#34;total_ridelogs&#34;]/90)
        dataframes_list = []

        pbar = tqdm(total=total_pages, desc=f&#34;Enumerating {region} Rider Pages&#34;)
        for i in range(1, total_pages + 1):
            try:
                domain = f&#34;https://www.trailforks.com/region/{region}/ridelogs/?viewMode=table&amp;page={i}&#34;
                tmp_df = pd.read_html(domain, index_col=None, header=0)

                # Sometimes we have more than 1 table on the page.
                if len(tmp_df) &gt;= 2:
                    for potential_df in tmp_df:
                        if &#34;city&#34; not in potential_df.columns:
                            good_df = potential_df
                            dataframes_list.append(good_df)
                else:
                    good_df = tmp_df[0]
                    dataframes_list.append(good_df)

                pbar.update(1)
            except Exception as e:
                pbar.update(1)
                break
        pbar.close()

        try:
            df = pd.concat(dataframes_list)
            df[&#34;region&#34;] = region
            return self.__clean_ridelogs(df)
        except Exception as e:
            print(f&#34;[!] Error: {e}&#34;)
            return pd.DataFrame


    def _get_region_info(self, region: str) -&gt; dict:
        &#34;&#34;&#34;
        Pulls region specific metrics from the region page

        Args:
            region (str): region name as is shows on a URI

        Returns:
            dict: {total_ridelogs, unique_riders, trails_ridden, avg_trails_per_ride}
        &#34;&#34;&#34;
        region_uri = f&#39;https://www.trailforks.com/region/{region}/ridelogstats/&#39;
        page = requests.get(region_uri)
        soup = BeautifulSoup(page.text, &#39;html.parser&#39;)
        data = soup.find_all(&#34;div&#34;, class_=&#34;col-2 center&#34;)
        data = str(data[0])
        soup_1 = BeautifulSoup(data, &#34;html.parser&#34;)
        list_items = soup_1.find_all(&#34;li&#34;)

        region_info = {
            &#34;total_ridelogs&#34;: None,
            &#34;unique_riders&#34;: None,
            &#34;trails_ridden&#34;: None,
            &#34;average_trails_per_ride&#34;: None
        }
        region_vars = [&#34;total_ridelogs&#34;, &#34;unique_riders&#34;, &#34;trails_ridden&#34;, &#34;average_trails_per_ride&#34;]

        for i, item in enumerate(list_items):
            region_info[region_vars[i]] = int(re.search(r&#39;&gt;([0-9].*)&lt;&#39;, str(item)).groups()[0].replace(&#34;,&#34;,&#34;&#34;))
        
        return region_info


    def _check_requires_region_admin(self, error_message: str) -&gt; bool:
        &#34;&#34;&#34;
        If we get an error on an authenticated function, it might be because
        the user in question is not a admin for the local trail/region and
        are just a standard user. This function determines this by looking at
        known error codes.

        Args:
            error_message (str): RAW Html error page 

        Returns:
            bool: True:action requires admin;False:action doesn&#39;t need admin
        &#34;&#34;&#34;
        error_messages = [&#34;Only trusted users can export&#34;]
        return any([x in error_message for x in error_messages])</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="PyForks.trailforks_region.TrailforksRegion"><code class="flex name class">
<span>class <span class="ident">TrailforksRegion</span></span>
<span>(</span><span>username=None, password=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrailforksRegion(Trailforks):

    def is_valid_region(self, region: str) -&gt; bool:
        &#34;&#34;&#34;
        Check to make sure a region name is a real region by
        making sure the page title is not Error

        Returns:
            bool: True:is an existing region;False:region does not exist.
        &#34;&#34;&#34;
        uri = f&#34;https://www.trailforks.com/region/{region}&#34;
        r = requests.get(uri)
        non_existent = &#34;&lt;title&gt;Error&lt;/title&gt;&#34;
        if non_existent in r.text:
            return False
        return True

    def check_region(self, region: str) -&gt; bool:
        &#34;&#34;&#34;
        A wrapper function for is_valid_region() that conducts an
        exit if the region is non-existant.

        Returns:
            bool: True: Region is valid
        &#34;&#34;&#34;
        if not self.is_valid_region(region):
            print(f&#34;[!] {region} is not a valid Trailforks Region.&#34;)
            exit(1)
        return True

    def __enrich_ridecounts(self, df: pd.DataFrame) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Takes in a Pandas Dataframe with messy data from Trailforks
        and cleans it up, adds values, and simply just normalizes it

        Args:
            df (pd.DataFrame): Raw Trailforks Data

        Returns:
            pd.DataFrame: Clean and Encriched Trailforks Data
        &#34;&#34;&#34;
        df[&#34;date&#34;] = pd.to_datetime(df[&#34;date&#34;])
        df[&#34;year&#34;] = df[&#34;date&#34;].dt.year
        df[&#39;month&#39;] = df[&#34;date&#34;].dt.month
        df[&#39;day&#39;] = df[&#34;date&#34;].dt.day
        df[&#39;weekday_num&#39;] = df[&#39;date&#39;].dt.weekday
        df[&#39;weekday&#39;] = df[&#34;date&#34;].dt.day_name()
        df[&#39;month_name&#39;] = df[&#39;month&#39;].apply(lambda x: calendar.month_abbr[x])

        return df

    @authentication
    def download_region_ridecounts(self, region: str) -&gt; bool:
        &#34;&#34;&#34;
        Downloads a regions total ridecounts is CSV format. Ideally, this should 
        be handled by the Trailforks API but, they&#39;ve not provisioning access 
        at this point (https://www.trailforks.com/about/api/)

        Args:
            region (str): Trailforks region name per URI
            output_path (str, optional): Where to store CSV Defaults to &#34;.&#34;.

        Returns:
            bool: true:CSV written to disk;False:failed to write CSV
        &#34;&#34;&#34;
        success = False
        self.check_region(region)
        uri = f&#34;https://www.trailforks.com/region/{region}/ridelogcountscsv/&#34;
        r = self.trailforks_session.get(uri, allow_redirects=True)
        raw_csv_data = r.text
        
        if &#34;date,rides&#34; in raw_csv_data:
            raw_df = pd.read_csv(io.StringIO(raw_csv_data))
            raw_df[&#34;region&#34;] = region
            return self.__enrich_ridecounts(raw_df)

        else:
            if self._check_requires_region_admin(r.text):
                print(f&#34;[!] Error: You need to be an Admin for {region} to download Trail Ridecounts&#34;)
            return pd.DataFrame

    def __clean_region_trails(self, df: pd.DataFrame) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Clean the region traillog data by converting distance data into 
        a useable metric (miles).

        Args:
            df (pd.DataFrame): _description_

        Returns:
            pd.DataFrame: _description_
        &#34;&#34;&#34;

        df[&#39;total_miles&#39;] = None
        df[&#39;descent_miles&#39;] = None
        df[&#39;ascent_miles&#39;] = None
        df[&#39;flat_miles&#39;] = None
        for index, row in df.iterrows():
            df.loc[index, &#39;total_miles&#39;] = self.feet_to_miles(str(row[&#39;distance&#39;]))
            df.loc[index, &#39;descent_miles&#39;] = self.feet_to_miles(str(row[&#39;dst_descent&#39;]))
            df.loc[index, &#39;ascent_miles&#39;] = self.feet_to_miles(str(row[&#39;dst_climb&#39;]))
            df.loc[index, &#39;flat_miles&#39;] = self.feet_to_miles(str(row[&#39;dst_flat&#39;]))
        df[&#39;total_miles&#39;] = df[&#39;total_miles&#39;].astype(float)
        df[&#39;descent_miles&#39;] = df[&#39;descent_miles&#39;].astype(float)
        df[&#39;ascent_miles&#39;] = df[&#39;ascent_miles&#39;].astype(float)
        df[&#39;flat_miles&#39;] = df[&#39;flat_miles&#39;].astype(float)

        return df

    def __clean_raw_csv_data(self, raw_data: str) -&gt; str:
        &#34;&#34;&#34;
        Trailforks CSV data is pretty bad in terms of quality. We
        need to clean things up quite a bit to get it into a dataframe

        Args:
            raw_data (str): raw CSV data

        Returns:
            str: cleaned csv data
        &#34;&#34;&#34;
        fix_csv_data = re.sub(r&#39;\nhttps&#39;, &#34;\&#34;,\&#34;https&#34;, raw_data)
        csv_data_list = []
        for line in fix_csv_data.split(&#34;\n&#34;):
            line = line.strip()                     # remove un-needed chars

            if &#34;title&#34; not in line:
                line = line[:-1]

            csv_data_list.append(line)

        return &#34;\n&#34;.join(csv_data_list)
        

    @authentication
    def download_all_region_trails(self, region: str, region_id: str) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Each region has a CSV export capability to export all trails within the region.
        This function automates that export for the end user and saves a csv to local
        disk. Ideally, this should be handled by the Trailforks API but,
        they&#39;ve not provisioning access at this point (https://www.trailforks.com/about/api/)

        Args:
            region (str): region name as is shows on a URI
            region_id (str): this is the integer (string representation) of the region
            output_path (str, optional): output directory for the CSV. Defaults to &#34;.&#34;.

        Returns:
            DataFrame: Pandas DataFrame
        &#34;&#34;&#34;
        success = False
        self.check_region(region)
        uri = f&#34;https://www.trailforks.com/tools/trailspreadsheet_csv/?cols=title,difficulty,region_title,distance,dst_climb,dst_descent,dst_flat&amp;rid={region_id}&#34;
        r = self.trailforks_session.get(uri, allow_redirects=True)
        raw_csv_data = r.text
        clean_csv_data = self.__clean_raw_csv_data(raw_csv_data)

        if &#34;title,difficulty&#34; in clean_csv_data:
            df = pd.read_csv(io.StringIO(clean_csv_data))
            return self.__clean_region_trails(df)
            #return df

        else:
            if self._check_requires_region_admin(r.text):
                print(f&#34;[!] Error: You need to be an Admin for {region} to download Trail Data&#34;)
            return pd.DataFrame()

    def __clean_ridelogs(self, df: pd.DataFrame) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Region ridelogs are messy AF! We need to normalize the distances and climb
        data for it to be useful. We will also re-name the dist and climb columns
        to denote their metric type (e.g., miles, feet, etc.)

        Args:
            df (pd.DataFrame): raw Data from Trailforks

        Returns:
            pd.DataFrame: Normalized Trailforks data
        &#34;&#34;&#34;
        date_rex = re.compile(r&#39;^\d{2,4}-\d{1,2}-\d{1,2}\s&#39;)
        try:
            df = df.rename(columns={&#34;dist&#34;: &#34;dist_miles&#34;, &#34;climb&#34;: &#34;climb_miles&#34;, &#34;created&#34;: &#34;date&#34;})
            for index, row in df.iterrows():
                df.loc[index, &#39;dist_miles&#39;] = self.distance_string_to_miles_float(str(row[&#39;dist_miles&#39;]))
                df.loc[index, &#39;climb_miles&#39;] = self.distance_string_to_miles_float(str(row[&#39;climb_miles&#39;]))
                df.loc[index, &#39;date&#39;] = date_rex.findall(row[&#39;date&#39;])[0]

            df[&#39;dist_miles&#39;] = df[&#39;dist_miles&#39;].astype(float)       # miles as float
            df[&#39;climb_miles&#39;] = df[&#39;climb_miles&#39;].astype(float)     # miles as float
            df[&#34;date&#34;] = pd.to_datetime(df[&#34;date&#34;])                 # cast to datetime
            df[&#34;year&#34;] = df[&#34;date&#34;].dt.year                         # get the year (int)
            df[&#39;month&#39;] = df[&#34;date&#34;].dt.month                       # get the month (int)
            df[&#39;day&#39;] = df[&#34;date&#34;].dt.day                           # get the day (int)
            df[&#39;weekday_num&#39;] = df[&#39;date&#39;].dt.weekday               # get the weekday (int)
            df[&#39;weekday&#39;] = df[&#34;date&#34;].dt.day_name()                # get the weekday (str)
            df[&#39;month_name&#39;] = df[&#39;month&#39;].apply(lambda x: calendar.month_abbr[x])
            df = df.loc[:, ~df.columns.str.contains(&#39;^Unnamed&#39;)]    # Drop unnamed columns
            df.fillna(&#34;unknown&#34;, inplace=True)

            return df
        except Exception as e:
            print(f&#34;[!!] ERROR {e}&#34;)
            return pd.DataFrame

    @authentication
    def download_all_region_ridelogs(self, region: str) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Downloads all of the trail ridelogs since the begining of the 
        trails existance and stores the results in CSV format on the 
        local disk. Ideally, this should be handled by the Trailforks API but,
        they&#39;ve not provisioning access at this point (https://www.trailforks.com/about/api)

        Args:
            region (str): region name as is shows on a URI
            output_path (str, optional): Path to store csv. Defaults to &#34;.&#34;.
            
        Returns:
            bool: Pandas DataFrame
        &#34;&#34;&#34;
        self.check_region(region)
        region_info = self._get_region_info(region)
        total_pages = round(region_info[&#34;total_ridelogs&#34;]/90)
        dataframes_list = []

        pbar = tqdm(total=total_pages, desc=f&#34;Enumerating {region} Rider Pages&#34;)
        for i in range(1, total_pages + 1):
            try:
                domain = f&#34;https://www.trailforks.com/region/{region}/ridelogs/?viewMode=table&amp;page={i}&#34;
                tmp_df = pd.read_html(domain, index_col=None, header=0)

                # Sometimes we have more than 1 table on the page.
                if len(tmp_df) &gt;= 2:
                    for potential_df in tmp_df:
                        if &#34;city&#34; not in potential_df.columns:
                            good_df = potential_df
                            dataframes_list.append(good_df)
                else:
                    good_df = tmp_df[0]
                    dataframes_list.append(good_df)

                pbar.update(1)
            except Exception as e:
                pbar.update(1)
                break
        pbar.close()

        try:
            df = pd.concat(dataframes_list)
            df[&#34;region&#34;] = region
            return self.__clean_ridelogs(df)
        except Exception as e:
            print(f&#34;[!] Error: {e}&#34;)
            return pd.DataFrame


    def _get_region_info(self, region: str) -&gt; dict:
        &#34;&#34;&#34;
        Pulls region specific metrics from the region page

        Args:
            region (str): region name as is shows on a URI

        Returns:
            dict: {total_ridelogs, unique_riders, trails_ridden, avg_trails_per_ride}
        &#34;&#34;&#34;
        region_uri = f&#39;https://www.trailforks.com/region/{region}/ridelogstats/&#39;
        page = requests.get(region_uri)
        soup = BeautifulSoup(page.text, &#39;html.parser&#39;)
        data = soup.find_all(&#34;div&#34;, class_=&#34;col-2 center&#34;)
        data = str(data[0])
        soup_1 = BeautifulSoup(data, &#34;html.parser&#34;)
        list_items = soup_1.find_all(&#34;li&#34;)

        region_info = {
            &#34;total_ridelogs&#34;: None,
            &#34;unique_riders&#34;: None,
            &#34;trails_ridden&#34;: None,
            &#34;average_trails_per_ride&#34;: None
        }
        region_vars = [&#34;total_ridelogs&#34;, &#34;unique_riders&#34;, &#34;trails_ridden&#34;, &#34;average_trails_per_ride&#34;]

        for i, item in enumerate(list_items):
            region_info[region_vars[i]] = int(re.search(r&#39;&gt;([0-9].*)&lt;&#39;, str(item)).groups()[0].replace(&#34;,&#34;,&#34;&#34;))
        
        return region_info


    def _check_requires_region_admin(self, error_message: str) -&gt; bool:
        &#34;&#34;&#34;
        If we get an error on an authenticated function, it might be because
        the user in question is not a admin for the local trail/region and
        are just a standard user. This function determines this by looking at
        known error codes.

        Args:
            error_message (str): RAW Html error page 

        Returns:
            bool: True:action requires admin;False:action doesn&#39;t need admin
        &#34;&#34;&#34;
        error_messages = [&#34;Only trusted users can export&#34;]
        return any([x in error_message for x in error_messages])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="PyForks.trailforks.Trailforks" href="trailforks.html#PyForks.trailforks.Trailforks">Trailforks</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="PyForks.trailforks_region.TrailforksRegion.check_region"><code class="name flex">
<span>def <span class="ident">check_region</span></span>(<span>self, region: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>A wrapper function for is_valid_region() that conducts an
exit if the region is non-existant.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True: Region is valid</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_region(self, region: str) -&gt; bool:
    &#34;&#34;&#34;
    A wrapper function for is_valid_region() that conducts an
    exit if the region is non-existant.

    Returns:
        bool: True: Region is valid
    &#34;&#34;&#34;
    if not self.is_valid_region(region):
        print(f&#34;[!] {region} is not a valid Trailforks Region.&#34;)
        exit(1)
    return True</code></pre>
</details>
</dd>
<dt id="PyForks.trailforks_region.TrailforksRegion.download_all_region_ridelogs"><code class="name flex">
<span>def <span class="ident">download_all_region_ridelogs</span></span>(<span>self, region: str) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Downloads all of the trail ridelogs since the begining of the
trails existance and stores the results in CSV format on the
local disk. Ideally, this should be handled by the Trailforks API but,
they've not provisioning access at this point (<a href="https://www.trailforks.com/about/api">https://www.trailforks.com/about/api</a>)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>region</code></strong> :&ensp;<code>str</code></dt>
<dd>region name as is shows on a URI</dd>
<dt><strong><code>output_path</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Path to store csv. Defaults to ".".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Pandas DataFrame</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@authentication
def download_all_region_ridelogs(self, region: str) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Downloads all of the trail ridelogs since the begining of the 
    trails existance and stores the results in CSV format on the 
    local disk. Ideally, this should be handled by the Trailforks API but,
    they&#39;ve not provisioning access at this point (https://www.trailforks.com/about/api)

    Args:
        region (str): region name as is shows on a URI
        output_path (str, optional): Path to store csv. Defaults to &#34;.&#34;.
        
    Returns:
        bool: Pandas DataFrame
    &#34;&#34;&#34;
    self.check_region(region)
    region_info = self._get_region_info(region)
    total_pages = round(region_info[&#34;total_ridelogs&#34;]/90)
    dataframes_list = []

    pbar = tqdm(total=total_pages, desc=f&#34;Enumerating {region} Rider Pages&#34;)
    for i in range(1, total_pages + 1):
        try:
            domain = f&#34;https://www.trailforks.com/region/{region}/ridelogs/?viewMode=table&amp;page={i}&#34;
            tmp_df = pd.read_html(domain, index_col=None, header=0)

            # Sometimes we have more than 1 table on the page.
            if len(tmp_df) &gt;= 2:
                for potential_df in tmp_df:
                    if &#34;city&#34; not in potential_df.columns:
                        good_df = potential_df
                        dataframes_list.append(good_df)
            else:
                good_df = tmp_df[0]
                dataframes_list.append(good_df)

            pbar.update(1)
        except Exception as e:
            pbar.update(1)
            break
    pbar.close()

    try:
        df = pd.concat(dataframes_list)
        df[&#34;region&#34;] = region
        return self.__clean_ridelogs(df)
    except Exception as e:
        print(f&#34;[!] Error: {e}&#34;)
        return pd.DataFrame</code></pre>
</details>
</dd>
<dt id="PyForks.trailforks_region.TrailforksRegion.download_all_region_trails"><code class="name flex">
<span>def <span class="ident">download_all_region_trails</span></span>(<span>self, region: str, region_id: str) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Each region has a CSV export capability to export all trails within the region.
This function automates that export for the end user and saves a csv to local
disk. Ideally, this should be handled by the Trailforks API but,
they've not provisioning access at this point (<a href="https://www.trailforks.com/about/api/">https://www.trailforks.com/about/api/</a>)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>region</code></strong> :&ensp;<code>str</code></dt>
<dd>region name as is shows on a URI</dd>
<dt><strong><code>region_id</code></strong> :&ensp;<code>str</code></dt>
<dd>this is the integer (string representation) of the region</dd>
<dt><strong><code>output_path</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>output directory for the CSV. Defaults to ".".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DataFrame</code></dt>
<dd>Pandas DataFrame</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@authentication
def download_all_region_trails(self, region: str, region_id: str) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Each region has a CSV export capability to export all trails within the region.
    This function automates that export for the end user and saves a csv to local
    disk. Ideally, this should be handled by the Trailforks API but,
    they&#39;ve not provisioning access at this point (https://www.trailforks.com/about/api/)

    Args:
        region (str): region name as is shows on a URI
        region_id (str): this is the integer (string representation) of the region
        output_path (str, optional): output directory for the CSV. Defaults to &#34;.&#34;.

    Returns:
        DataFrame: Pandas DataFrame
    &#34;&#34;&#34;
    success = False
    self.check_region(region)
    uri = f&#34;https://www.trailforks.com/tools/trailspreadsheet_csv/?cols=title,difficulty,region_title,distance,dst_climb,dst_descent,dst_flat&amp;rid={region_id}&#34;
    r = self.trailforks_session.get(uri, allow_redirects=True)
    raw_csv_data = r.text
    clean_csv_data = self.__clean_raw_csv_data(raw_csv_data)

    if &#34;title,difficulty&#34; in clean_csv_data:
        df = pd.read_csv(io.StringIO(clean_csv_data))
        return self.__clean_region_trails(df)
        #return df

    else:
        if self._check_requires_region_admin(r.text):
            print(f&#34;[!] Error: You need to be an Admin for {region} to download Trail Data&#34;)
        return pd.DataFrame()</code></pre>
</details>
</dd>
<dt id="PyForks.trailforks_region.TrailforksRegion.download_region_ridecounts"><code class="name flex">
<span>def <span class="ident">download_region_ridecounts</span></span>(<span>self, region: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Downloads a regions total ridecounts is CSV format. Ideally, this should
be handled by the Trailforks API but, they've not provisioning access
at this point (<a href="https://www.trailforks.com/about/api/">https://www.trailforks.com/about/api/</a>)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>region</code></strong> :&ensp;<code>str</code></dt>
<dd>Trailforks region name per URI</dd>
<dt><strong><code>output_path</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Where to store CSV Defaults to ".".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>true:CSV written to disk;False:failed to write CSV</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@authentication
def download_region_ridecounts(self, region: str) -&gt; bool:
    &#34;&#34;&#34;
    Downloads a regions total ridecounts is CSV format. Ideally, this should 
    be handled by the Trailforks API but, they&#39;ve not provisioning access 
    at this point (https://www.trailforks.com/about/api/)

    Args:
        region (str): Trailforks region name per URI
        output_path (str, optional): Where to store CSV Defaults to &#34;.&#34;.

    Returns:
        bool: true:CSV written to disk;False:failed to write CSV
    &#34;&#34;&#34;
    success = False
    self.check_region(region)
    uri = f&#34;https://www.trailforks.com/region/{region}/ridelogcountscsv/&#34;
    r = self.trailforks_session.get(uri, allow_redirects=True)
    raw_csv_data = r.text
    
    if &#34;date,rides&#34; in raw_csv_data:
        raw_df = pd.read_csv(io.StringIO(raw_csv_data))
        raw_df[&#34;region&#34;] = region
        return self.__enrich_ridecounts(raw_df)

    else:
        if self._check_requires_region_admin(r.text):
            print(f&#34;[!] Error: You need to be an Admin for {region} to download Trail Ridecounts&#34;)
        return pd.DataFrame</code></pre>
</details>
</dd>
<dt id="PyForks.trailforks_region.TrailforksRegion.is_valid_region"><code class="name flex">
<span>def <span class="ident">is_valid_region</span></span>(<span>self, region: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check to make sure a region name is a real region by
making sure the page title is not Error</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True:is an existing region;False:region does not exist.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_valid_region(self, region: str) -&gt; bool:
    &#34;&#34;&#34;
    Check to make sure a region name is a real region by
    making sure the page title is not Error

    Returns:
        bool: True:is an existing region;False:region does not exist.
    &#34;&#34;&#34;
    uri = f&#34;https://www.trailforks.com/region/{region}&#34;
    r = requests.get(uri)
    non_existent = &#34;&lt;title&gt;Error&lt;/title&gt;&#34;
    if non_existent in r.text:
        return False
    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="PyForks.trailforks.Trailforks" href="trailforks.html#PyForks.trailforks.Trailforks">Trailforks</a></b></code>:
<ul class="hlist">
<li><code><a title="PyForks.trailforks.Trailforks.distance_string_to_miles_float" href="trailforks.html#PyForks.trailforks.Trailforks.distance_string_to_miles_float">distance_string_to_miles_float</a></code></li>
<li><code><a title="PyForks.trailforks.Trailforks.feet_to_miles" href="trailforks.html#PyForks.trailforks.Trailforks.feet_to_miles">feet_to_miles</a></code></li>
<li><code><a title="PyForks.trailforks.Trailforks.login" href="trailforks.html#PyForks.trailforks.Trailforks.login">login</a></code></li>
<li><code><a title="PyForks.trailforks.Trailforks.uri_encode" href="trailforks.html#PyForks.trailforks.Trailforks.uri_encode">uri_encode</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<center><img src="PyForks.png" width="60%"/></center>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="PyForks" href="index.html">PyForks</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="PyForks.trailforks_region.TrailforksRegion" href="#PyForks.trailforks_region.TrailforksRegion">TrailforksRegion</a></code></h4>
<ul class="">
<li><code><a title="PyForks.trailforks_region.TrailforksRegion.check_region" href="#PyForks.trailforks_region.TrailforksRegion.check_region">check_region</a></code></li>
<li><code><a title="PyForks.trailforks_region.TrailforksRegion.download_all_region_ridelogs" href="#PyForks.trailforks_region.TrailforksRegion.download_all_region_ridelogs">download_all_region_ridelogs</a></code></li>
<li><code><a title="PyForks.trailforks_region.TrailforksRegion.download_all_region_trails" href="#PyForks.trailforks_region.TrailforksRegion.download_all_region_trails">download_all_region_trails</a></code></li>
<li><code><a title="PyForks.trailforks_region.TrailforksRegion.download_region_ridecounts" href="#PyForks.trailforks_region.TrailforksRegion.download_region_ridecounts">download_region_ridecounts</a></code></li>
<li><code><a title="PyForks.trailforks_region.TrailforksRegion.is_valid_region" href="#PyForks.trailforks_region.TrailforksRegion.is_valid_region">is_valid_region</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>