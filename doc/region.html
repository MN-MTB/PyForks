<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>PyForks.region API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>PyForks.region</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import pandas as pd
import logging
from datetime import datetime
import PyForks.exceptions
import calendar
from tqdm import tqdm
from PyForks.trailforks import Trailforks, authentication


class Region(Trailforks):
    def is_valid_region(self, region: str) -&gt; bool:
        &#34;&#34;&#34;
        Check to make sure a region name is a real region by
        making sure the page title is not Error

        Returns:
            bool: True:is an existing region;False:region does not exist.
        &#34;&#34;&#34;  # noqa
        filter = self.uri_encode(f&#34;alias::{region}&#34;)
        uri = f&#34;https://www.trailforks.com/api/1/regions?filter={filter}&amp;app_id={self.app_id}&amp;app_secret={self.app_secret}&#34;
        r = self.trailforks_session.get(uri)
        r_json = r.json()
        r_json_data = r_json[&#39;data&#39;]
        if len(r_json_data) == 0:
            return False
        return True

    def check_region(self, region: str) -&gt; bool:
        &#34;&#34;&#34;
        A wrapper function for is_valid_region() that conducts an
        exit if the region is non-existant.

        Returns:
            bool: True: Region is valid
        &#34;&#34;&#34;  # noqa
        if not self.is_valid_region(region):
            raise PyForks.exceptions.InvalidRegion(
                msg=f&#34;[!] {region} is not a valid Trailforks Region.&#34;
            )
        return True

    def __enrich_ridecounts(self, df: pd.DataFrame) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Takes in a Pandas Dataframe with messy data from Trailforks
        and cleans it up, adds values, and simply just normalizes it

        Args:
            df (pd.DataFrame): Raw Trailforks Data

        Returns:
            pd.DataFrame: Clean and Enriched Trailforks Data
        &#34;&#34;&#34;  # noqa
        df[&#34;date&#34;] = pd.to_datetime(df[&#34;date&#34;])
        df[&#34;year&#34;] = df[&#34;date&#34;].dt.year
        df[&#34;month&#34;] = df[&#34;date&#34;].dt.month
        df[&#34;day&#34;] = df[&#34;date&#34;].dt.day
        df[&#34;weekday_num&#34;] = df[&#34;date&#34;].dt.weekday
        df[&#34;weekday&#34;] = df[&#34;date&#34;].dt.day_name()
        df[&#34;month_name&#34;] = df[&#34;month&#34;].apply(lambda x: calendar.month_abbr[x])

        return df

    
    @authentication
    def get_region_ridecounts(self, region: str) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Creates a dataframe that contains that year-month-day and the
        number of rides associated with that day.

        Args:
            region (str): URI name of the region

        Returns:
            pd.DataFrame: pd.Dataframe(columns=[&#34;date&#34;,&#34;rides&#34;])
        &#34;&#34;&#34; # noqa
        self.check_region(region)
        rows_per_pull = 500
        page_number = 0
        enumerated_results = 0
        fields = self.uri_encode(&#34;created&#34;)
        region_id = self.get_region_id_by_alias(region)
        region_info = self.get_region_info(region)
        total_ridelogs = int(region_info[&#34;ridden&#34;])
        region_filter = self.uri_encode(f&#34;::{region_id}&#34;)
        dfs = []

        while enumerated_results &lt; total_ridelogs:
            url = f&#34;https://www.trailforks.com/api/1/ridelogs?fields={fields}&amp;filter=rid{region_filter}&amp;rows={rows_per_pull}&amp;page={page_number}&amp;order=desc&amp;sort=created&amp;app_id={self.app_id}&amp;app_secret={self.app_secret}&#34;
            r = self.trailforks_session.get(url)
            url_json = r.json()
            self._handle_status_code(r.status_code, url_json[&#34;message&#34;])
            url_json_data = url_json[&#34;data&#34;]
            dfs.append(pd.json_normalize(url_json_data))
            page_number += 1
            enumerated_results += rows_per_pull

        df = pd.concat(dfs, ignore_index=True)
        df[&#34;date&#34;] = pd.to_datetime(df[&#39;created&#39;],unit=&#34;s&#34;).dt.strftime(&#34;%Y-%m-%d&#34;)
        t_df = df.groupby([&#39;date&#39;], sort=False)[&#39;date&#39;].count().sort_index(ascending=False).reset_index(name=&#34;rides&#34;)
        return self.__enrich_ridecounts(t_df)


    def _handle_status_code(self, status_code: int, message: str) -&gt; None:
        &#34;&#34;&#34;
        Handle unauthenticated or incorrect permissions errors for HTTP requests

        Args:
            status_code (int): HTTP Status Code
            message (str): Trailforks API Message

        Raises:
            PyForks.exceptions.RegionLockedAPI: 401 is usually tied to a failure in permissions for a token
        &#34;&#34;&#34;
        if status_code == 401:
            raise PyForks.exceptions.RegionLockedAPI(
                msg=f&#34;[!] Error: {message}&#34;
            )

    @authentication
    def get_all_region_trails(self, region: str) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Each region has a CSV export capability to export all trails within the region.
        This function automates that export for the end user and saves a csv to local
        disk. Ideally, this should be handled by the Trailforks API but,
        they&#39;ve not provisioning access at this point (https://www.trailforks.com/about/api/)

        Args:
            region (str): region name as is shows on a URI
            region_id (str): this is the integer (string representation) of the region
            output_path (str, optional): output directory for the CSV. Defaults to &#34;.&#34;.

        Returns:
            DataFrame: Pandas DataFrame
        &#34;&#34;&#34;  # noqa
        self.check_region(region)
        fields = self.uri_encode(&#34;created,title,difficulty,physical_rating,total_jumps,total_poi,alias,faved,stats&#34;)
        region_id = self.get_region_id_by_alias(region)
        region_filter = self.uri_encode(f&#34;rid::{region_id}&#34;)
        rows = 100
        url = f&#34;https://www.trailforks.com/api/1/trails?scope=full&amp;fields={fields}&amp;filter={region_filter}&amp;rows={rows}&amp;app_id={self.app_id}&amp;app_secret={self.app_secret}&#34;
        r = self.trailforks_session.get(url)
        url_json = r.json()
        self._handle_status_code(r.status_code, url_json[&#34;message&#34;])
        url_json_data = url_json[&#34;data&#34;]
        df = pd.json_normalize(url_json_data)
        return df

    @authentication
    def get_all_region_ridelogs(self, region: str, pages=1) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Downloads all of the trail ridelogs since the begining of the
        trails existance and stores the results in CSV format on the
        local disk. Ideally, this should be handled by the Trailforks API but,
        they&#39;ve not provisioning access at this point (https://www.trailforks.com/about/api)

        Args:
            region (str): region name as is shows on a URI
            pages(int): The number of pages (HTML) to enumerate 1page == ~100 rides

        Returns:
            bool: Pandas DataFrame
        &#34;&#34;&#34;  # noqa
        self.check_region(region)
        def get_date_string(row) -&gt; int:
            epoch = float(row[&#34;created&#34;])
            date = datetime.fromtimestamp(epoch).strftime(&#34;%m/%d/%Y&#34;)
            return date


        rows_per_pull = 100
        page_number = 0
        fields = self.uri_encode(&#34;note,created,location_name,location_id,year,device_name,username&#34;)
        region_id = self.get_region_id_by_alias(region)
        region_filter = self.uri_encode(f&#34;::{region_id}&#34;)
        dfs = []

        for i in range(0,pages):
            url = f&#34;https://www.trailforks.com/api/1/ridelogs?fields={fields}&amp;filter=rid{region_filter}&amp;rows={rows_per_pull}&amp;page={page_number}&amp;order=desc&amp;sort=created&amp;app_id={self.app_id}&amp;app_secret={self.app_secret}&#34;
            r = self.trailforks_session.get(url)
            url_json = r.json()
            self._handle_status_code(r.status_code, url_json[&#34;message&#34;])
            url_json_data = url_json[&#34;data&#34;]
            dfs.append(pd.json_normalize(url_json_data))
            page_number += 1
        
        final_df = pd.concat(dfs, ignore_index=True)
        final_df[&#34;date&#34;] = final_df.apply(get_date_string, axis=1)
        return final_df

    def get_region_id_by_alias(self, region_alias: str) -&gt; int:
        &#34;&#34;&#34;
        Given a region alias (the URI name of the region), obtain the region
        id (int) and return it

        Args:
            region_alias (str): URI name of the region

        Returns:
            int: Trailforks Region ID
        &#34;&#34;&#34;
        df = pd.read_parquet(self.region_data_file, engine=&#34;pyarrow&#34;)
        region_id = df.loc[df[&#34;alias&#34;] == region_alias, &#39;rid&#39;].item()
        return region_id
    
    @authentication
    def get_region_info(self, region: str) -&gt; dict:
        &#34;&#34;&#34;
        Pulls region specific metrics from the region page. This whole function
        is an abomination (I know) but, until Trailforks publishes an API I do
        not see another way around this.

        Args:
            region (str): region name as is shows on a URI

        Returns:
            dict: {total_ridelogs, unique_riders, trails_ridden, avg_trails_per_ride}
        &#34;&#34;&#34;  # noqa
        self.check_region(region)
        region_id = self.get_region_id_by_alias(region)
        url = f&#34;https://www.trailforks.com/api/1/region?id={region_id}&amp;scope=detailed&amp;app_id={self.app_id}&amp;app_secret={self.app_secret}&#34;
        r = self.trailforks_session.get(url)
        r_json = r.json()
        self._handle_status_code(r.status_code, r_json[&#34;message&#34;])
        r_json_data = r_json[&#34;data&#34;]

        region_info = {
            &#34;region_title&#34;: r_json_data[&#34;title&#34;],
            &#34;total_ridelogs&#34;: r_json_data[&#34;total_ridelogs&#34;],
            &#34;total_trails&#34;: r_json_data[&#34;total_trails&#34;],
            &#34;total_distance&#34;: self.meters_to_miles(r_json_data[&#34;total_distance&#34;]),
            &#34;total_descent&#34;: self.meters_to_miles(r_json_data[&#34;total_descent_distance&#34;]),
            &#34;highest_trailhead&#34;: self.meters_to_miles(r_json_data[&#34;highest_trailhead&#34;]),
            &#34;reports&#34;: r_json_data[&#34;total_reports&#34;],
            &#34;photos&#34;: r_json_data[&#34;total_photos&#34;],
            &#34;ridden&#34;: r_json_data[&#34;ridden&#34;],
            &#34;country&#34;: r_json_data[&#34;country_title&#34;],
            &#34;state_province&#34;: r_json_data[&#34;prov_title&#34;],
            &#34;city&#34;: r_json_data[&#34;city_title&#34;],
            &#34;links&#34;: r_json_data[&#34;links&#34;],
            &#34;favorites&#34;: r_json_data[&#34;faved&#34;],
            &#34;rating&#34;: r_json_data[&#34;rating&#34;],
            &#34;region_created&#34;: r_json_data[&#34;created&#34;]
        }
        return region_info

    @authentication
    def get_all_trailforks_regions(self) -&gt; pd.DataFrame: # noqa
        &#34;&#34;&#34;
        BETA FUNCTION - retrieves all of the regions Trailforks knows about

        Returns:
            pd.DataFrame: DataFrame of all region data
        &#34;&#34;&#34;
        number_of_regions = 40_000
        enumerated_results = 0
        page_number = 0
        results_per_page = 500
        fields = self.uri_encode(&#34;rid,title,alias&#34;)
        dfs = []

        pbar = tqdm(total=number_of_regions)
        while enumerated_results &lt;= number_of_regions:
            url = f&#34;https://www.trailforks.com/api/1/regions?scope=basic&amp;app_id={self.app_id}&amp;fields={fields}&amp;app_secret={self.app_secret}&amp;rows={results_per_page}&amp;page={page_number}&#34;
            headers = {
                &#34;User-Agent&#34;: &#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100102 Firefox/102.0&#34;
            }
            r = self.trailforks_session.get(url, headers=headers, allow_redirects=True)
            t_json = r.json()
            self._handle_status_code(r.status_code, t_json[&#34;message&#34;])
            dfs.append(pd.json_normalize(t_json[&#34;data&#34;]))
            page_number += 1
            enumerated_results += results_per_page
            pbar.update(results_per_page)
        pbar.close()
        final_df = pd.concat(dfs)

        return final_df</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="PyForks.region.Region"><code class="flex name class">
<span>class <span class="ident">Region</span></span>
<span>(</span><span>app_id=None, app_secret=None, debug=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Region(Trailforks):
    def is_valid_region(self, region: str) -&gt; bool:
        &#34;&#34;&#34;
        Check to make sure a region name is a real region by
        making sure the page title is not Error

        Returns:
            bool: True:is an existing region;False:region does not exist.
        &#34;&#34;&#34;  # noqa
        filter = self.uri_encode(f&#34;alias::{region}&#34;)
        uri = f&#34;https://www.trailforks.com/api/1/regions?filter={filter}&amp;app_id={self.app_id}&amp;app_secret={self.app_secret}&#34;
        r = self.trailforks_session.get(uri)
        r_json = r.json()
        r_json_data = r_json[&#39;data&#39;]
        if len(r_json_data) == 0:
            return False
        return True

    def check_region(self, region: str) -&gt; bool:
        &#34;&#34;&#34;
        A wrapper function for is_valid_region() that conducts an
        exit if the region is non-existant.

        Returns:
            bool: True: Region is valid
        &#34;&#34;&#34;  # noqa
        if not self.is_valid_region(region):
            raise PyForks.exceptions.InvalidRegion(
                msg=f&#34;[!] {region} is not a valid Trailforks Region.&#34;
            )
        return True

    def __enrich_ridecounts(self, df: pd.DataFrame) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Takes in a Pandas Dataframe with messy data from Trailforks
        and cleans it up, adds values, and simply just normalizes it

        Args:
            df (pd.DataFrame): Raw Trailforks Data

        Returns:
            pd.DataFrame: Clean and Enriched Trailforks Data
        &#34;&#34;&#34;  # noqa
        df[&#34;date&#34;] = pd.to_datetime(df[&#34;date&#34;])
        df[&#34;year&#34;] = df[&#34;date&#34;].dt.year
        df[&#34;month&#34;] = df[&#34;date&#34;].dt.month
        df[&#34;day&#34;] = df[&#34;date&#34;].dt.day
        df[&#34;weekday_num&#34;] = df[&#34;date&#34;].dt.weekday
        df[&#34;weekday&#34;] = df[&#34;date&#34;].dt.day_name()
        df[&#34;month_name&#34;] = df[&#34;month&#34;].apply(lambda x: calendar.month_abbr[x])

        return df

    
    @authentication
    def get_region_ridecounts(self, region: str) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Creates a dataframe that contains that year-month-day and the
        number of rides associated with that day.

        Args:
            region (str): URI name of the region

        Returns:
            pd.DataFrame: pd.Dataframe(columns=[&#34;date&#34;,&#34;rides&#34;])
        &#34;&#34;&#34; # noqa
        self.check_region(region)
        rows_per_pull = 500
        page_number = 0
        enumerated_results = 0
        fields = self.uri_encode(&#34;created&#34;)
        region_id = self.get_region_id_by_alias(region)
        region_info = self.get_region_info(region)
        total_ridelogs = int(region_info[&#34;ridden&#34;])
        region_filter = self.uri_encode(f&#34;::{region_id}&#34;)
        dfs = []

        while enumerated_results &lt; total_ridelogs:
            url = f&#34;https://www.trailforks.com/api/1/ridelogs?fields={fields}&amp;filter=rid{region_filter}&amp;rows={rows_per_pull}&amp;page={page_number}&amp;order=desc&amp;sort=created&amp;app_id={self.app_id}&amp;app_secret={self.app_secret}&#34;
            r = self.trailforks_session.get(url)
            url_json = r.json()
            self._handle_status_code(r.status_code, url_json[&#34;message&#34;])
            url_json_data = url_json[&#34;data&#34;]
            dfs.append(pd.json_normalize(url_json_data))
            page_number += 1
            enumerated_results += rows_per_pull

        df = pd.concat(dfs, ignore_index=True)
        df[&#34;date&#34;] = pd.to_datetime(df[&#39;created&#39;],unit=&#34;s&#34;).dt.strftime(&#34;%Y-%m-%d&#34;)
        t_df = df.groupby([&#39;date&#39;], sort=False)[&#39;date&#39;].count().sort_index(ascending=False).reset_index(name=&#34;rides&#34;)
        return self.__enrich_ridecounts(t_df)


    def _handle_status_code(self, status_code: int, message: str) -&gt; None:
        &#34;&#34;&#34;
        Handle unauthenticated or incorrect permissions errors for HTTP requests

        Args:
            status_code (int): HTTP Status Code
            message (str): Trailforks API Message

        Raises:
            PyForks.exceptions.RegionLockedAPI: 401 is usually tied to a failure in permissions for a token
        &#34;&#34;&#34;
        if status_code == 401:
            raise PyForks.exceptions.RegionLockedAPI(
                msg=f&#34;[!] Error: {message}&#34;
            )

    @authentication
    def get_all_region_trails(self, region: str) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Each region has a CSV export capability to export all trails within the region.
        This function automates that export for the end user and saves a csv to local
        disk. Ideally, this should be handled by the Trailforks API but,
        they&#39;ve not provisioning access at this point (https://www.trailforks.com/about/api/)

        Args:
            region (str): region name as is shows on a URI
            region_id (str): this is the integer (string representation) of the region
            output_path (str, optional): output directory for the CSV. Defaults to &#34;.&#34;.

        Returns:
            DataFrame: Pandas DataFrame
        &#34;&#34;&#34;  # noqa
        self.check_region(region)
        fields = self.uri_encode(&#34;created,title,difficulty,physical_rating,total_jumps,total_poi,alias,faved,stats&#34;)
        region_id = self.get_region_id_by_alias(region)
        region_filter = self.uri_encode(f&#34;rid::{region_id}&#34;)
        rows = 100
        url = f&#34;https://www.trailforks.com/api/1/trails?scope=full&amp;fields={fields}&amp;filter={region_filter}&amp;rows={rows}&amp;app_id={self.app_id}&amp;app_secret={self.app_secret}&#34;
        r = self.trailforks_session.get(url)
        url_json = r.json()
        self._handle_status_code(r.status_code, url_json[&#34;message&#34;])
        url_json_data = url_json[&#34;data&#34;]
        df = pd.json_normalize(url_json_data)
        return df

    @authentication
    def get_all_region_ridelogs(self, region: str, pages=1) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Downloads all of the trail ridelogs since the begining of the
        trails existance and stores the results in CSV format on the
        local disk. Ideally, this should be handled by the Trailforks API but,
        they&#39;ve not provisioning access at this point (https://www.trailforks.com/about/api)

        Args:
            region (str): region name as is shows on a URI
            pages(int): The number of pages (HTML) to enumerate 1page == ~100 rides

        Returns:
            bool: Pandas DataFrame
        &#34;&#34;&#34;  # noqa
        self.check_region(region)
        def get_date_string(row) -&gt; int:
            epoch = float(row[&#34;created&#34;])
            date = datetime.fromtimestamp(epoch).strftime(&#34;%m/%d/%Y&#34;)
            return date


        rows_per_pull = 100
        page_number = 0
        fields = self.uri_encode(&#34;note,created,location_name,location_id,year,device_name,username&#34;)
        region_id = self.get_region_id_by_alias(region)
        region_filter = self.uri_encode(f&#34;::{region_id}&#34;)
        dfs = []

        for i in range(0,pages):
            url = f&#34;https://www.trailforks.com/api/1/ridelogs?fields={fields}&amp;filter=rid{region_filter}&amp;rows={rows_per_pull}&amp;page={page_number}&amp;order=desc&amp;sort=created&amp;app_id={self.app_id}&amp;app_secret={self.app_secret}&#34;
            r = self.trailforks_session.get(url)
            url_json = r.json()
            self._handle_status_code(r.status_code, url_json[&#34;message&#34;])
            url_json_data = url_json[&#34;data&#34;]
            dfs.append(pd.json_normalize(url_json_data))
            page_number += 1
        
        final_df = pd.concat(dfs, ignore_index=True)
        final_df[&#34;date&#34;] = final_df.apply(get_date_string, axis=1)
        return final_df

    def get_region_id_by_alias(self, region_alias: str) -&gt; int:
        &#34;&#34;&#34;
        Given a region alias (the URI name of the region), obtain the region
        id (int) and return it

        Args:
            region_alias (str): URI name of the region

        Returns:
            int: Trailforks Region ID
        &#34;&#34;&#34;
        df = pd.read_parquet(self.region_data_file, engine=&#34;pyarrow&#34;)
        region_id = df.loc[df[&#34;alias&#34;] == region_alias, &#39;rid&#39;].item()
        return region_id
    
    @authentication
    def get_region_info(self, region: str) -&gt; dict:
        &#34;&#34;&#34;
        Pulls region specific metrics from the region page. This whole function
        is an abomination (I know) but, until Trailforks publishes an API I do
        not see another way around this.

        Args:
            region (str): region name as is shows on a URI

        Returns:
            dict: {total_ridelogs, unique_riders, trails_ridden, avg_trails_per_ride}
        &#34;&#34;&#34;  # noqa
        self.check_region(region)
        region_id = self.get_region_id_by_alias(region)
        url = f&#34;https://www.trailforks.com/api/1/region?id={region_id}&amp;scope=detailed&amp;app_id={self.app_id}&amp;app_secret={self.app_secret}&#34;
        r = self.trailforks_session.get(url)
        r_json = r.json()
        self._handle_status_code(r.status_code, r_json[&#34;message&#34;])
        r_json_data = r_json[&#34;data&#34;]

        region_info = {
            &#34;region_title&#34;: r_json_data[&#34;title&#34;],
            &#34;total_ridelogs&#34;: r_json_data[&#34;total_ridelogs&#34;],
            &#34;total_trails&#34;: r_json_data[&#34;total_trails&#34;],
            &#34;total_distance&#34;: self.meters_to_miles(r_json_data[&#34;total_distance&#34;]),
            &#34;total_descent&#34;: self.meters_to_miles(r_json_data[&#34;total_descent_distance&#34;]),
            &#34;highest_trailhead&#34;: self.meters_to_miles(r_json_data[&#34;highest_trailhead&#34;]),
            &#34;reports&#34;: r_json_data[&#34;total_reports&#34;],
            &#34;photos&#34;: r_json_data[&#34;total_photos&#34;],
            &#34;ridden&#34;: r_json_data[&#34;ridden&#34;],
            &#34;country&#34;: r_json_data[&#34;country_title&#34;],
            &#34;state_province&#34;: r_json_data[&#34;prov_title&#34;],
            &#34;city&#34;: r_json_data[&#34;city_title&#34;],
            &#34;links&#34;: r_json_data[&#34;links&#34;],
            &#34;favorites&#34;: r_json_data[&#34;faved&#34;],
            &#34;rating&#34;: r_json_data[&#34;rating&#34;],
            &#34;region_created&#34;: r_json_data[&#34;created&#34;]
        }
        return region_info

    @authentication
    def get_all_trailforks_regions(self) -&gt; pd.DataFrame: # noqa
        &#34;&#34;&#34;
        BETA FUNCTION - retrieves all of the regions Trailforks knows about

        Returns:
            pd.DataFrame: DataFrame of all region data
        &#34;&#34;&#34;
        number_of_regions = 40_000
        enumerated_results = 0
        page_number = 0
        results_per_page = 500
        fields = self.uri_encode(&#34;rid,title,alias&#34;)
        dfs = []

        pbar = tqdm(total=number_of_regions)
        while enumerated_results &lt;= number_of_regions:
            url = f&#34;https://www.trailforks.com/api/1/regions?scope=basic&amp;app_id={self.app_id}&amp;fields={fields}&amp;app_secret={self.app_secret}&amp;rows={results_per_page}&amp;page={page_number}&#34;
            headers = {
                &#34;User-Agent&#34;: &#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100102 Firefox/102.0&#34;
            }
            r = self.trailforks_session.get(url, headers=headers, allow_redirects=True)
            t_json = r.json()
            self._handle_status_code(r.status_code, t_json[&#34;message&#34;])
            dfs.append(pd.json_normalize(t_json[&#34;data&#34;]))
            page_number += 1
            enumerated_results += results_per_page
            pbar.update(results_per_page)
        pbar.close()
        final_df = pd.concat(dfs)

        return final_df</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="PyForks.trailforks.Trailforks" href="trailforks.html#PyForks.trailforks.Trailforks">Trailforks</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="PyForks.region.Region.check_region"><code class="name flex">
<span>def <span class="ident">check_region</span></span>(<span>self, region: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>A wrapper function for is_valid_region() that conducts an
exit if the region is non-existant.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True: Region is valid</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_region(self, region: str) -&gt; bool:
    &#34;&#34;&#34;
    A wrapper function for is_valid_region() that conducts an
    exit if the region is non-existant.

    Returns:
        bool: True: Region is valid
    &#34;&#34;&#34;  # noqa
    if not self.is_valid_region(region):
        raise PyForks.exceptions.InvalidRegion(
            msg=f&#34;[!] {region} is not a valid Trailforks Region.&#34;
        )
    return True</code></pre>
</details>
</dd>
<dt id="PyForks.region.Region.get_all_region_ridelogs"><code class="name flex">
<span>def <span class="ident">get_all_region_ridelogs</span></span>(<span>self, region: str, pages=1) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Downloads all of the trail ridelogs since the begining of the
trails existance and stores the results in CSV format on the
local disk. Ideally, this should be handled by the Trailforks API but,
they've not provisioning access at this point (<a href="https://www.trailforks.com/about/api">https://www.trailforks.com/about/api</a>)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>region</code></strong> :&ensp;<code>str</code></dt>
<dd>region name as is shows on a URI</dd>
</dl>
<p>pages(int): The number of pages (HTML) to enumerate 1page == ~100 rides</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Pandas DataFrame</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@authentication
def get_all_region_ridelogs(self, region: str, pages=1) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Downloads all of the trail ridelogs since the begining of the
    trails existance and stores the results in CSV format on the
    local disk. Ideally, this should be handled by the Trailforks API but,
    they&#39;ve not provisioning access at this point (https://www.trailforks.com/about/api)

    Args:
        region (str): region name as is shows on a URI
        pages(int): The number of pages (HTML) to enumerate 1page == ~100 rides

    Returns:
        bool: Pandas DataFrame
    &#34;&#34;&#34;  # noqa
    self.check_region(region)
    def get_date_string(row) -&gt; int:
        epoch = float(row[&#34;created&#34;])
        date = datetime.fromtimestamp(epoch).strftime(&#34;%m/%d/%Y&#34;)
        return date


    rows_per_pull = 100
    page_number = 0
    fields = self.uri_encode(&#34;note,created,location_name,location_id,year,device_name,username&#34;)
    region_id = self.get_region_id_by_alias(region)
    region_filter = self.uri_encode(f&#34;::{region_id}&#34;)
    dfs = []

    for i in range(0,pages):
        url = f&#34;https://www.trailforks.com/api/1/ridelogs?fields={fields}&amp;filter=rid{region_filter}&amp;rows={rows_per_pull}&amp;page={page_number}&amp;order=desc&amp;sort=created&amp;app_id={self.app_id}&amp;app_secret={self.app_secret}&#34;
        r = self.trailforks_session.get(url)
        url_json = r.json()
        self._handle_status_code(r.status_code, url_json[&#34;message&#34;])
        url_json_data = url_json[&#34;data&#34;]
        dfs.append(pd.json_normalize(url_json_data))
        page_number += 1
    
    final_df = pd.concat(dfs, ignore_index=True)
    final_df[&#34;date&#34;] = final_df.apply(get_date_string, axis=1)
    return final_df</code></pre>
</details>
</dd>
<dt id="PyForks.region.Region.get_all_region_trails"><code class="name flex">
<span>def <span class="ident">get_all_region_trails</span></span>(<span>self, region: str) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Each region has a CSV export capability to export all trails within the region.
This function automates that export for the end user and saves a csv to local
disk. Ideally, this should be handled by the Trailforks API but,
they've not provisioning access at this point (<a href="https://www.trailforks.com/about/api/">https://www.trailforks.com/about/api/</a>)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>region</code></strong> :&ensp;<code>str</code></dt>
<dd>region name as is shows on a URI</dd>
<dt><strong><code>region_id</code></strong> :&ensp;<code>str</code></dt>
<dd>this is the integer (string representation) of the region</dd>
<dt><strong><code>output_path</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>output directory for the CSV. Defaults to ".".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DataFrame</code></dt>
<dd>Pandas DataFrame</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@authentication
def get_all_region_trails(self, region: str) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Each region has a CSV export capability to export all trails within the region.
    This function automates that export for the end user and saves a csv to local
    disk. Ideally, this should be handled by the Trailforks API but,
    they&#39;ve not provisioning access at this point (https://www.trailforks.com/about/api/)

    Args:
        region (str): region name as is shows on a URI
        region_id (str): this is the integer (string representation) of the region
        output_path (str, optional): output directory for the CSV. Defaults to &#34;.&#34;.

    Returns:
        DataFrame: Pandas DataFrame
    &#34;&#34;&#34;  # noqa
    self.check_region(region)
    fields = self.uri_encode(&#34;created,title,difficulty,physical_rating,total_jumps,total_poi,alias,faved,stats&#34;)
    region_id = self.get_region_id_by_alias(region)
    region_filter = self.uri_encode(f&#34;rid::{region_id}&#34;)
    rows = 100
    url = f&#34;https://www.trailforks.com/api/1/trails?scope=full&amp;fields={fields}&amp;filter={region_filter}&amp;rows={rows}&amp;app_id={self.app_id}&amp;app_secret={self.app_secret}&#34;
    r = self.trailforks_session.get(url)
    url_json = r.json()
    self._handle_status_code(r.status_code, url_json[&#34;message&#34;])
    url_json_data = url_json[&#34;data&#34;]
    df = pd.json_normalize(url_json_data)
    return df</code></pre>
</details>
</dd>
<dt id="PyForks.region.Region.get_all_trailforks_regions"><code class="name flex">
<span>def <span class="ident">get_all_trailforks_regions</span></span>(<span>self) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>BETA FUNCTION - retrieves all of the regions Trailforks knows about</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>DataFrame of all region data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@authentication
def get_all_trailforks_regions(self) -&gt; pd.DataFrame: # noqa
    &#34;&#34;&#34;
    BETA FUNCTION - retrieves all of the regions Trailforks knows about

    Returns:
        pd.DataFrame: DataFrame of all region data
    &#34;&#34;&#34;
    number_of_regions = 40_000
    enumerated_results = 0
    page_number = 0
    results_per_page = 500
    fields = self.uri_encode(&#34;rid,title,alias&#34;)
    dfs = []

    pbar = tqdm(total=number_of_regions)
    while enumerated_results &lt;= number_of_regions:
        url = f&#34;https://www.trailforks.com/api/1/regions?scope=basic&amp;app_id={self.app_id}&amp;fields={fields}&amp;app_secret={self.app_secret}&amp;rows={results_per_page}&amp;page={page_number}&#34;
        headers = {
            &#34;User-Agent&#34;: &#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100102 Firefox/102.0&#34;
        }
        r = self.trailforks_session.get(url, headers=headers, allow_redirects=True)
        t_json = r.json()
        self._handle_status_code(r.status_code, t_json[&#34;message&#34;])
        dfs.append(pd.json_normalize(t_json[&#34;data&#34;]))
        page_number += 1
        enumerated_results += results_per_page
        pbar.update(results_per_page)
    pbar.close()
    final_df = pd.concat(dfs)

    return final_df</code></pre>
</details>
</dd>
<dt id="PyForks.region.Region.get_region_id_by_alias"><code class="name flex">
<span>def <span class="ident">get_region_id_by_alias</span></span>(<span>self, region_alias: str) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Given a region alias (the URI name of the region), obtain the region
id (int) and return it</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>region_alias</code></strong> :&ensp;<code>str</code></dt>
<dd>URI name of the region</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Trailforks Region ID</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_region_id_by_alias(self, region_alias: str) -&gt; int:
    &#34;&#34;&#34;
    Given a region alias (the URI name of the region), obtain the region
    id (int) and return it

    Args:
        region_alias (str): URI name of the region

    Returns:
        int: Trailforks Region ID
    &#34;&#34;&#34;
    df = pd.read_parquet(self.region_data_file, engine=&#34;pyarrow&#34;)
    region_id = df.loc[df[&#34;alias&#34;] == region_alias, &#39;rid&#39;].item()
    return region_id</code></pre>
</details>
</dd>
<dt id="PyForks.region.Region.get_region_info"><code class="name flex">
<span>def <span class="ident">get_region_info</span></span>(<span>self, region: str) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Pulls region specific metrics from the region page. This whole function
is an abomination (I know) but, until Trailforks publishes an API I do
not see another way around this.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>region</code></strong> :&ensp;<code>str</code></dt>
<dd>region name as is shows on a URI</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>{total_ridelogs, unique_riders, trails_ridden, avg_trails_per_ride}</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@authentication
def get_region_info(self, region: str) -&gt; dict:
    &#34;&#34;&#34;
    Pulls region specific metrics from the region page. This whole function
    is an abomination (I know) but, until Trailforks publishes an API I do
    not see another way around this.

    Args:
        region (str): region name as is shows on a URI

    Returns:
        dict: {total_ridelogs, unique_riders, trails_ridden, avg_trails_per_ride}
    &#34;&#34;&#34;  # noqa
    self.check_region(region)
    region_id = self.get_region_id_by_alias(region)
    url = f&#34;https://www.trailforks.com/api/1/region?id={region_id}&amp;scope=detailed&amp;app_id={self.app_id}&amp;app_secret={self.app_secret}&#34;
    r = self.trailforks_session.get(url)
    r_json = r.json()
    self._handle_status_code(r.status_code, r_json[&#34;message&#34;])
    r_json_data = r_json[&#34;data&#34;]

    region_info = {
        &#34;region_title&#34;: r_json_data[&#34;title&#34;],
        &#34;total_ridelogs&#34;: r_json_data[&#34;total_ridelogs&#34;],
        &#34;total_trails&#34;: r_json_data[&#34;total_trails&#34;],
        &#34;total_distance&#34;: self.meters_to_miles(r_json_data[&#34;total_distance&#34;]),
        &#34;total_descent&#34;: self.meters_to_miles(r_json_data[&#34;total_descent_distance&#34;]),
        &#34;highest_trailhead&#34;: self.meters_to_miles(r_json_data[&#34;highest_trailhead&#34;]),
        &#34;reports&#34;: r_json_data[&#34;total_reports&#34;],
        &#34;photos&#34;: r_json_data[&#34;total_photos&#34;],
        &#34;ridden&#34;: r_json_data[&#34;ridden&#34;],
        &#34;country&#34;: r_json_data[&#34;country_title&#34;],
        &#34;state_province&#34;: r_json_data[&#34;prov_title&#34;],
        &#34;city&#34;: r_json_data[&#34;city_title&#34;],
        &#34;links&#34;: r_json_data[&#34;links&#34;],
        &#34;favorites&#34;: r_json_data[&#34;faved&#34;],
        &#34;rating&#34;: r_json_data[&#34;rating&#34;],
        &#34;region_created&#34;: r_json_data[&#34;created&#34;]
    }
    return region_info</code></pre>
</details>
</dd>
<dt id="PyForks.region.Region.get_region_ridecounts"><code class="name flex">
<span>def <span class="ident">get_region_ridecounts</span></span>(<span>self, region: str) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a dataframe that contains that year-month-day and the
number of rides associated with that day.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>region</code></strong> :&ensp;<code>str</code></dt>
<dd>URI name of the region</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>pd.Dataframe(columns=["date","rides"])</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@authentication
def get_region_ridecounts(self, region: str) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Creates a dataframe that contains that year-month-day and the
    number of rides associated with that day.

    Args:
        region (str): URI name of the region

    Returns:
        pd.DataFrame: pd.Dataframe(columns=[&#34;date&#34;,&#34;rides&#34;])
    &#34;&#34;&#34; # noqa
    self.check_region(region)
    rows_per_pull = 500
    page_number = 0
    enumerated_results = 0
    fields = self.uri_encode(&#34;created&#34;)
    region_id = self.get_region_id_by_alias(region)
    region_info = self.get_region_info(region)
    total_ridelogs = int(region_info[&#34;ridden&#34;])
    region_filter = self.uri_encode(f&#34;::{region_id}&#34;)
    dfs = []

    while enumerated_results &lt; total_ridelogs:
        url = f&#34;https://www.trailforks.com/api/1/ridelogs?fields={fields}&amp;filter=rid{region_filter}&amp;rows={rows_per_pull}&amp;page={page_number}&amp;order=desc&amp;sort=created&amp;app_id={self.app_id}&amp;app_secret={self.app_secret}&#34;
        r = self.trailforks_session.get(url)
        url_json = r.json()
        self._handle_status_code(r.status_code, url_json[&#34;message&#34;])
        url_json_data = url_json[&#34;data&#34;]
        dfs.append(pd.json_normalize(url_json_data))
        page_number += 1
        enumerated_results += rows_per_pull

    df = pd.concat(dfs, ignore_index=True)
    df[&#34;date&#34;] = pd.to_datetime(df[&#39;created&#39;],unit=&#34;s&#34;).dt.strftime(&#34;%Y-%m-%d&#34;)
    t_df = df.groupby([&#39;date&#39;], sort=False)[&#39;date&#39;].count().sort_index(ascending=False).reset_index(name=&#34;rides&#34;)
    return self.__enrich_ridecounts(t_df)</code></pre>
</details>
</dd>
<dt id="PyForks.region.Region.is_valid_region"><code class="name flex">
<span>def <span class="ident">is_valid_region</span></span>(<span>self, region: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check to make sure a region name is a real region by
making sure the page title is not Error</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True:is an existing region;False:region does not exist.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_valid_region(self, region: str) -&gt; bool:
    &#34;&#34;&#34;
    Check to make sure a region name is a real region by
    making sure the page title is not Error

    Returns:
        bool: True:is an existing region;False:region does not exist.
    &#34;&#34;&#34;  # noqa
    filter = self.uri_encode(f&#34;alias::{region}&#34;)
    uri = f&#34;https://www.trailforks.com/api/1/regions?filter={filter}&amp;app_id={self.app_id}&amp;app_secret={self.app_secret}&#34;
    r = self.trailforks_session.get(uri)
    r_json = r.json()
    r_json_data = r_json[&#39;data&#39;]
    if len(r_json_data) == 0:
        return False
    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="PyForks.trailforks.Trailforks" href="trailforks.html#PyForks.trailforks.Trailforks">Trailforks</a></b></code>:
<ul class="hlist">
<li><code><a title="PyForks.trailforks.Trailforks.distance_string_to_miles_float" href="trailforks.html#PyForks.trailforks.Trailforks.distance_string_to_miles_float">distance_string_to_miles_float</a></code></li>
<li><code><a title="PyForks.trailforks.Trailforks.feet_to_miles" href="trailforks.html#PyForks.trailforks.Trailforks.feet_to_miles">feet_to_miles</a></code></li>
<li><code><a title="PyForks.trailforks.Trailforks.has_numbers" href="trailforks.html#PyForks.trailforks.Trailforks.has_numbers">has_numbers</a></code></li>
<li><code><a title="PyForks.trailforks.Trailforks.meters_to_miles" href="trailforks.html#PyForks.trailforks.Trailforks.meters_to_miles">meters_to_miles</a></code></li>
<li><code><a title="PyForks.trailforks.Trailforks.uri_encode" href="trailforks.html#PyForks.trailforks.Trailforks.uri_encode">uri_encode</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<center><img src="PyForks.png" width="60%"/></center>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="PyForks" href="index.html">PyForks</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="PyForks.region.Region" href="#PyForks.region.Region">Region</a></code></h4>
<ul class="">
<li><code><a title="PyForks.region.Region.check_region" href="#PyForks.region.Region.check_region">check_region</a></code></li>
<li><code><a title="PyForks.region.Region.get_all_region_ridelogs" href="#PyForks.region.Region.get_all_region_ridelogs">get_all_region_ridelogs</a></code></li>
<li><code><a title="PyForks.region.Region.get_all_region_trails" href="#PyForks.region.Region.get_all_region_trails">get_all_region_trails</a></code></li>
<li><code><a title="PyForks.region.Region.get_all_trailforks_regions" href="#PyForks.region.Region.get_all_trailforks_regions">get_all_trailforks_regions</a></code></li>
<li><code><a title="PyForks.region.Region.get_region_id_by_alias" href="#PyForks.region.Region.get_region_id_by_alias">get_region_id_by_alias</a></code></li>
<li><code><a title="PyForks.region.Region.get_region_info" href="#PyForks.region.Region.get_region_info">get_region_info</a></code></li>
<li><code><a title="PyForks.region.Region.get_region_ridecounts" href="#PyForks.region.Region.get_region_ridecounts">get_region_ridecounts</a></code></li>
<li><code><a title="PyForks.region.Region.is_valid_region" href="#PyForks.region.Region.is_valid_region">is_valid_region</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>