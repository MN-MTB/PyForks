<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>PyForks.region API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>PyForks.region</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import pandas as pd
import logging
from datetime import datetime
import PyForks.exceptions
import calendar
from tqdm import tqdm
from PyForks.trailforks import Trailforks, authentication

class Region(Trailforks):
    def is_valid_region(self, region: str) -&gt; bool:
        &#34;&#34;&#34;
        Check to make sure a region name is a real region by
        making sure the page title is not Error

        Returns:
            bool: True:is an existing region;False:region does not exist.
        &#34;&#34;&#34;  # noqa
        filter = self.uri_encode(f&#34;alias::{region}&#34;)
        uri = f&#34;https://www.trailforks.com/api/1/regions?filter={filter}&amp;app_id={self.app_id}&amp;app_secret={self.app_secret}&#34;
        json_response = self.make_trailforks_request(uri)
        if len(json_response) == 0:
            return False
        return True

    def check_region(self, region: str) -&gt; bool:
        &#34;&#34;&#34;
        A wrapper function for is_valid_region() that conducts an
        exit if the region is non-existant.

        Returns:
            bool: True: Region is valid
        &#34;&#34;&#34;  # noqa
        if not self.is_valid_region(region):
            raise PyForks.exceptions.InvalidRegion(
                msg=f&#34;[!] {region} is not a valid Trailforks Region.&#34;
            )
        return True

    def __enrich_ridecounts(self, df: pd.DataFrame) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Takes in a Pandas Dataframe with messy data from Trailforks
        and cleans it up, adds values, and simply just normalizes it

        Args:
            df (pd.DataFrame): Raw Trailforks Data

        Returns:
            pd.DataFrame: adds new datetime columns (columns=[year,month,day,weekday_num,weekday,month_name])
        &#34;&#34;&#34;  # noqa
        df[&#34;date&#34;] = pd.to_datetime(df[&#34;date&#34;])
        df[&#34;year&#34;] = df[&#34;date&#34;].dt.year
        df[&#34;month&#34;] = df[&#34;date&#34;].dt.month
        df[&#34;day&#34;] = df[&#34;date&#34;].dt.day
        df[&#34;weekday_num&#34;] = df[&#34;date&#34;].dt.weekday
        df[&#34;weekday&#34;] = df[&#34;date&#34;].dt.day_name()
        df[&#34;month_name&#34;] = df[&#34;month&#34;].apply(lambda x: calendar.month_abbr[x])

        return df

    
    @authentication
    def get_region_ridecounts(self, region: str) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Creates a dataframe that contains that year-month-day and the
        number of rides associated with that day.

        Args:
            region (str): URI name of the region

        Returns:
            pd.DataFrame: pd.DataFrame(columns=[&#34;date&#34;,&#34;rides&#34;])
        &#34;&#34;&#34; # noqa
        self.check_region(region)
        rows_per_pull = 500
        page_number = 0
        enumerated_results = 0
        fields = self.uri_encode(&#34;created&#34;)
        region_id = self.get_region_id_by_alias(region)
        region_info = self.get_region_info(region)
        total_ridelogs = int(region_info[&#34;ridden&#34;])
        region_filter = self.uri_encode(f&#34;::{region_id}&#34;)
        dfs = []

        while enumerated_results &lt; total_ridelogs:
            uri = f&#34;https://www.trailforks.com/api/1/ridelogs?fields={fields}&amp;filter=rid{region_filter}&amp;rows={rows_per_pull}&amp;page={page_number}&amp;order=desc&amp;sort=created&amp;app_id={self.app_id}&amp;app_secret={self.app_secret}&#34;
            json_response = self.make_trailforks_request(uri)
            dfs.append(pd.json_normalize(json_response))
            page_number += 1
            enumerated_results += rows_per_pull

        df = pd.concat(dfs, ignore_index=True)
        df[&#34;date&#34;] = pd.to_datetime(df[&#39;created&#39;],unit=&#34;s&#34;).dt.strftime(&#34;%Y-%m-%d&#34;)
        t_df = df.groupby([&#39;date&#39;], sort=False)[&#39;date&#39;].count().sort_index(ascending=False).reset_index(name=&#34;rides&#34;)
        return self.__enrich_ridecounts(t_df)

    @authentication
    def get_all_region_trails(self, region: str) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Queries the Trailforks Trails API to obtain trail information for
        a given region

        Args:
            region (str): region uri name (alias)

        Returns:
            pd.DataFrame: Pandas DataFrame(columns=[created,title,difficulty,physical_rating,total_jumps,total_poi,alias,faved,stats])
        &#34;&#34;&#34;
         # noqa
        self.check_region(region)
        fields = self.uri_encode(&#34;created,title,difficulty,physical_rating,total_jumps,total_poi,alias,faved,stats&#34;)
        region_id = self.get_region_id_by_alias(region)
        region_filter = self.uri_encode(f&#34;rid::{region_id}&#34;)
        rows = 100
        uri = f&#34;https://www.trailforks.com/api/1/trails?scope=full&amp;fields={fields}&amp;filter={region_filter}&amp;rows={rows}&amp;app_id={self.app_id}&amp;app_secret={self.app_secret}&#34;
        json_response = self.make_trailforks_request(uri)
        df = pd.json_normalize(json_response)
        return df

    @authentication
    def get_all_region_ridelogs(self, region: str, pages=1) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Downloads all of the trail ridelogs since the beginning of the
        trails existence and stores the results in CSV format on the
        local disk. Ideally, this should be handled by the Trailforks API but,
        they&#39;ve not provisioning access at this point (https://www.trailforks.com/about/api)

        Args:
            region (str): region name as is shows on a URI
            pages(int): The number of pages (HTML) to enumerate 1page == ~100 rides

        Returns:
            bool: Pandas DataFrame(columns=[note,created,location_name,location_id,year,device_name,username])
        &#34;&#34;&#34;  # noqa
        self.check_region(region)
        def get_date_string(row) -&gt; int:
            epoch = float(row[&#34;created&#34;])
            date = datetime.fromtimestamp(epoch).strftime(&#34;%m/%d/%Y&#34;)
            return date

        rows_per_pull = 100
        page_number = 0
        fields = self.uri_encode(&#34;note,created,location_name,location_id,year,device_name,username&#34;)
        region_id = self.get_region_id_by_alias(region)
        region_filter = self.uri_encode(f&#34;::{region_id}&#34;)
        dfs = []

        for i in range(0,pages):
            uri = f&#34;https://www.trailforks.com/api/1/ridelogs?fields={fields}&amp;filter=rid{region_filter}&amp;rows={rows_per_pull}&amp;page={page_number}&amp;order=desc&amp;sort=created&amp;app_id={self.app_id}&amp;app_secret={self.app_secret}&#34;
            json_response = self.make_trailforks_request(uri)
            dfs.append(pd.json_normalize(json_response))
            page_number += 1
        
        final_df = pd.concat(dfs, ignore_index=True)
        final_df[&#34;date&#34;] = final_df.apply(get_date_string, axis=1)
        return final_df

    def get_region_id_by_alias(self, region_alias: str) -&gt; int:
        &#34;&#34;&#34;
        Given a region alias (the URI name of the region), obtain the region
        id (int) and return it

        Args:
            region_alias (str): URI name of the region

        Returns:
            int: Trailforks Region ID
        &#34;&#34;&#34;
        df = pd.read_parquet(self.region_data_file, engine=&#34;pyarrow&#34;)
        region_id = df.loc[df[&#34;alias&#34;] == region_alias, &#39;rid&#39;].item()
        return region_id
    
    @authentication
    def get_region_info(self, region: str) -&gt; dict:
        &#34;&#34;&#34;
        Pulls region specific metrics from the region page. This whole function
        is an abomination (I know) but, until Trailforks publishes an API I do
        not see another way around this.

        Args:
            region (str): region name as is shows on a URI

        Returns:
            dict: {
                region_title:       string,
                total_ridelogs:     int,
                total_trails:       int,
                total_distance:     float,
                total_descent:      float,
                highest_trailhead:  float,
                reports:            int,
                photos:             int,
                ridden:             int,
                country:            string,
                state_province:     string,
                city:               string,
                links:              list,
                favorites:          int,
                rating:             int,
                region_created      int
            }
        &#34;&#34;&#34;  # noqa
        self.check_region(region)
        region_id = self.get_region_id_by_alias(region)
        uri = f&#34;https://www.trailforks.com/api/1/region?id={region_id}&amp;scope=detailed&amp;app_id={self.app_id}&amp;app_secret={self.app_secret}&#34;
        json_response = self.make_trailforks_request(uri)

        region_info = {
            &#34;region_title&#34;: json_response[&#34;title&#34;],
            &#34;total_ridelogs&#34;: json_response[&#34;total_ridelogs&#34;],
            &#34;total_trails&#34;: json_response[&#34;total_trails&#34;],
            &#34;total_distance&#34;: self.meters_to_miles(json_response[&#34;total_distance&#34;]),
            &#34;total_descent&#34;: self.meters_to_miles(json_response[&#34;total_descent_distance&#34;]),
            &#34;highest_trailhead&#34;: self.meters_to_miles(json_response[&#34;highest_trailhead&#34;]),
            &#34;reports&#34;: json_response[&#34;total_reports&#34;],
            &#34;photos&#34;: json_response[&#34;total_photos&#34;],
            &#34;ridden&#34;: json_response[&#34;ridden&#34;],
            &#34;country&#34;: json_response[&#34;country_title&#34;],
            &#34;state_province&#34;: json_response[&#34;prov_title&#34;],
            &#34;city&#34;: json_response[&#34;city_title&#34;],
            &#34;links&#34;: json_response[&#34;links&#34;],
            &#34;favorites&#34;: json_response[&#34;faved&#34;],
            &#34;rating&#34;: json_response[&#34;rating&#34;],
            &#34;region_created&#34;: json_response[&#34;created&#34;]
        }
        return region_info

    @authentication
    def get_all_trailforks_regions(self, number_of_regions=40_000) -&gt; pd.DataFrame: 
        &#34;&#34;&#34;
        Retrieve all known regions listed on Trailforks or a subset of regions
        subject to the number_of_regions parameter

        Args:
            number_of_regions (int, optional): Number of regions to pull. Defaults to 40_000 and the minimum is 500.

        Returns:
            pd.DataFrame: DataFrame(columns=[&#39;rid&#39;, &#39;title&#39;, &#39;alias&#39;])
        &#34;&#34;&#34;
         # noqa
        enumerated_results = 0
        page_number = 0
        results_per_page = 500
        fields = self.uri_encode(&#34;rid,title,alias&#34;)
        dfs = []

        pbar = tqdm(total=number_of_regions)
        while enumerated_results &lt;= number_of_regions:
            uri = f&#34;https://www.trailforks.com/api/1/regions?scope=basic&amp;app_id={self.app_id}&amp;fields={fields}&amp;app_secret={self.app_secret}&amp;rows={results_per_page}&amp;page={page_number}&#34;
            json_response = self.make_trailforks_request(uri)
            dfs.append(pd.json_normalize(json_response))
            page_number += 1
            enumerated_results += results_per_page
            pbar.update(results_per_page)
        pbar.close()
        final_df = pd.concat(dfs)
        final_df.astype(str).drop_duplicates(inplace=True)
        return final_df</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="PyForks.region.Region"><code class="flex name class">
<span>class <span class="ident">Region</span></span>
<span>(</span><span>app_id=None, app_secret=None, debug=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Region(Trailforks):
    def is_valid_region(self, region: str) -&gt; bool:
        &#34;&#34;&#34;
        Check to make sure a region name is a real region by
        making sure the page title is not Error

        Returns:
            bool: True:is an existing region;False:region does not exist.
        &#34;&#34;&#34;  # noqa
        filter = self.uri_encode(f&#34;alias::{region}&#34;)
        uri = f&#34;https://www.trailforks.com/api/1/regions?filter={filter}&amp;app_id={self.app_id}&amp;app_secret={self.app_secret}&#34;
        json_response = self.make_trailforks_request(uri)
        if len(json_response) == 0:
            return False
        return True

    def check_region(self, region: str) -&gt; bool:
        &#34;&#34;&#34;
        A wrapper function for is_valid_region() that conducts an
        exit if the region is non-existant.

        Returns:
            bool: True: Region is valid
        &#34;&#34;&#34;  # noqa
        if not self.is_valid_region(region):
            raise PyForks.exceptions.InvalidRegion(
                msg=f&#34;[!] {region} is not a valid Trailforks Region.&#34;
            )
        return True

    def __enrich_ridecounts(self, df: pd.DataFrame) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Takes in a Pandas Dataframe with messy data from Trailforks
        and cleans it up, adds values, and simply just normalizes it

        Args:
            df (pd.DataFrame): Raw Trailforks Data

        Returns:
            pd.DataFrame: adds new datetime columns (columns=[year,month,day,weekday_num,weekday,month_name])
        &#34;&#34;&#34;  # noqa
        df[&#34;date&#34;] = pd.to_datetime(df[&#34;date&#34;])
        df[&#34;year&#34;] = df[&#34;date&#34;].dt.year
        df[&#34;month&#34;] = df[&#34;date&#34;].dt.month
        df[&#34;day&#34;] = df[&#34;date&#34;].dt.day
        df[&#34;weekday_num&#34;] = df[&#34;date&#34;].dt.weekday
        df[&#34;weekday&#34;] = df[&#34;date&#34;].dt.day_name()
        df[&#34;month_name&#34;] = df[&#34;month&#34;].apply(lambda x: calendar.month_abbr[x])

        return df

    
    @authentication
    def get_region_ridecounts(self, region: str) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Creates a dataframe that contains that year-month-day and the
        number of rides associated with that day.

        Args:
            region (str): URI name of the region

        Returns:
            pd.DataFrame: pd.DataFrame(columns=[&#34;date&#34;,&#34;rides&#34;])
        &#34;&#34;&#34; # noqa
        self.check_region(region)
        rows_per_pull = 500
        page_number = 0
        enumerated_results = 0
        fields = self.uri_encode(&#34;created&#34;)
        region_id = self.get_region_id_by_alias(region)
        region_info = self.get_region_info(region)
        total_ridelogs = int(region_info[&#34;ridden&#34;])
        region_filter = self.uri_encode(f&#34;::{region_id}&#34;)
        dfs = []

        while enumerated_results &lt; total_ridelogs:
            uri = f&#34;https://www.trailforks.com/api/1/ridelogs?fields={fields}&amp;filter=rid{region_filter}&amp;rows={rows_per_pull}&amp;page={page_number}&amp;order=desc&amp;sort=created&amp;app_id={self.app_id}&amp;app_secret={self.app_secret}&#34;
            json_response = self.make_trailforks_request(uri)
            dfs.append(pd.json_normalize(json_response))
            page_number += 1
            enumerated_results += rows_per_pull

        df = pd.concat(dfs, ignore_index=True)
        df[&#34;date&#34;] = pd.to_datetime(df[&#39;created&#39;],unit=&#34;s&#34;).dt.strftime(&#34;%Y-%m-%d&#34;)
        t_df = df.groupby([&#39;date&#39;], sort=False)[&#39;date&#39;].count().sort_index(ascending=False).reset_index(name=&#34;rides&#34;)
        return self.__enrich_ridecounts(t_df)

    @authentication
    def get_all_region_trails(self, region: str) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Queries the Trailforks Trails API to obtain trail information for
        a given region

        Args:
            region (str): region uri name (alias)

        Returns:
            pd.DataFrame: Pandas DataFrame(columns=[created,title,difficulty,physical_rating,total_jumps,total_poi,alias,faved,stats])
        &#34;&#34;&#34;
         # noqa
        self.check_region(region)
        fields = self.uri_encode(&#34;created,title,difficulty,physical_rating,total_jumps,total_poi,alias,faved,stats&#34;)
        region_id = self.get_region_id_by_alias(region)
        region_filter = self.uri_encode(f&#34;rid::{region_id}&#34;)
        rows = 100
        uri = f&#34;https://www.trailforks.com/api/1/trails?scope=full&amp;fields={fields}&amp;filter={region_filter}&amp;rows={rows}&amp;app_id={self.app_id}&amp;app_secret={self.app_secret}&#34;
        json_response = self.make_trailforks_request(uri)
        df = pd.json_normalize(json_response)
        return df

    @authentication
    def get_all_region_ridelogs(self, region: str, pages=1) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Downloads all of the trail ridelogs since the beginning of the
        trails existence and stores the results in CSV format on the
        local disk. Ideally, this should be handled by the Trailforks API but,
        they&#39;ve not provisioning access at this point (https://www.trailforks.com/about/api)

        Args:
            region (str): region name as is shows on a URI
            pages(int): The number of pages (HTML) to enumerate 1page == ~100 rides

        Returns:
            bool: Pandas DataFrame(columns=[note,created,location_name,location_id,year,device_name,username])
        &#34;&#34;&#34;  # noqa
        self.check_region(region)
        def get_date_string(row) -&gt; int:
            epoch = float(row[&#34;created&#34;])
            date = datetime.fromtimestamp(epoch).strftime(&#34;%m/%d/%Y&#34;)
            return date

        rows_per_pull = 100
        page_number = 0
        fields = self.uri_encode(&#34;note,created,location_name,location_id,year,device_name,username&#34;)
        region_id = self.get_region_id_by_alias(region)
        region_filter = self.uri_encode(f&#34;::{region_id}&#34;)
        dfs = []

        for i in range(0,pages):
            uri = f&#34;https://www.trailforks.com/api/1/ridelogs?fields={fields}&amp;filter=rid{region_filter}&amp;rows={rows_per_pull}&amp;page={page_number}&amp;order=desc&amp;sort=created&amp;app_id={self.app_id}&amp;app_secret={self.app_secret}&#34;
            json_response = self.make_trailforks_request(uri)
            dfs.append(pd.json_normalize(json_response))
            page_number += 1
        
        final_df = pd.concat(dfs, ignore_index=True)
        final_df[&#34;date&#34;] = final_df.apply(get_date_string, axis=1)
        return final_df

    def get_region_id_by_alias(self, region_alias: str) -&gt; int:
        &#34;&#34;&#34;
        Given a region alias (the URI name of the region), obtain the region
        id (int) and return it

        Args:
            region_alias (str): URI name of the region

        Returns:
            int: Trailforks Region ID
        &#34;&#34;&#34;
        df = pd.read_parquet(self.region_data_file, engine=&#34;pyarrow&#34;)
        region_id = df.loc[df[&#34;alias&#34;] == region_alias, &#39;rid&#39;].item()
        return region_id
    
    @authentication
    def get_region_info(self, region: str) -&gt; dict:
        &#34;&#34;&#34;
        Pulls region specific metrics from the region page. This whole function
        is an abomination (I know) but, until Trailforks publishes an API I do
        not see another way around this.

        Args:
            region (str): region name as is shows on a URI

        Returns:
            dict: {
                region_title:       string,
                total_ridelogs:     int,
                total_trails:       int,
                total_distance:     float,
                total_descent:      float,
                highest_trailhead:  float,
                reports:            int,
                photos:             int,
                ridden:             int,
                country:            string,
                state_province:     string,
                city:               string,
                links:              list,
                favorites:          int,
                rating:             int,
                region_created      int
            }
        &#34;&#34;&#34;  # noqa
        self.check_region(region)
        region_id = self.get_region_id_by_alias(region)
        uri = f&#34;https://www.trailforks.com/api/1/region?id={region_id}&amp;scope=detailed&amp;app_id={self.app_id}&amp;app_secret={self.app_secret}&#34;
        json_response = self.make_trailforks_request(uri)

        region_info = {
            &#34;region_title&#34;: json_response[&#34;title&#34;],
            &#34;total_ridelogs&#34;: json_response[&#34;total_ridelogs&#34;],
            &#34;total_trails&#34;: json_response[&#34;total_trails&#34;],
            &#34;total_distance&#34;: self.meters_to_miles(json_response[&#34;total_distance&#34;]),
            &#34;total_descent&#34;: self.meters_to_miles(json_response[&#34;total_descent_distance&#34;]),
            &#34;highest_trailhead&#34;: self.meters_to_miles(json_response[&#34;highest_trailhead&#34;]),
            &#34;reports&#34;: json_response[&#34;total_reports&#34;],
            &#34;photos&#34;: json_response[&#34;total_photos&#34;],
            &#34;ridden&#34;: json_response[&#34;ridden&#34;],
            &#34;country&#34;: json_response[&#34;country_title&#34;],
            &#34;state_province&#34;: json_response[&#34;prov_title&#34;],
            &#34;city&#34;: json_response[&#34;city_title&#34;],
            &#34;links&#34;: json_response[&#34;links&#34;],
            &#34;favorites&#34;: json_response[&#34;faved&#34;],
            &#34;rating&#34;: json_response[&#34;rating&#34;],
            &#34;region_created&#34;: json_response[&#34;created&#34;]
        }
        return region_info

    @authentication
    def get_all_trailforks_regions(self, number_of_regions=40_000) -&gt; pd.DataFrame: 
        &#34;&#34;&#34;
        Retrieve all known regions listed on Trailforks or a subset of regions
        subject to the number_of_regions parameter

        Args:
            number_of_regions (int, optional): Number of regions to pull. Defaults to 40_000 and the minimum is 500.

        Returns:
            pd.DataFrame: DataFrame(columns=[&#39;rid&#39;, &#39;title&#39;, &#39;alias&#39;])
        &#34;&#34;&#34;
         # noqa
        enumerated_results = 0
        page_number = 0
        results_per_page = 500
        fields = self.uri_encode(&#34;rid,title,alias&#34;)
        dfs = []

        pbar = tqdm(total=number_of_regions)
        while enumerated_results &lt;= number_of_regions:
            uri = f&#34;https://www.trailforks.com/api/1/regions?scope=basic&amp;app_id={self.app_id}&amp;fields={fields}&amp;app_secret={self.app_secret}&amp;rows={results_per_page}&amp;page={page_number}&#34;
            json_response = self.make_trailforks_request(uri)
            dfs.append(pd.json_normalize(json_response))
            page_number += 1
            enumerated_results += results_per_page
            pbar.update(results_per_page)
        pbar.close()
        final_df = pd.concat(dfs)
        final_df.astype(str).drop_duplicates(inplace=True)
        return final_df</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="PyForks.trailforks.Trailforks" href="trailforks.html#PyForks.trailforks.Trailforks">Trailforks</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="PyForks.region.Region.check_region"><code class="name flex">
<span>def <span class="ident">check_region</span></span>(<span>self, region: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>A wrapper function for is_valid_region() that conducts an
exit if the region is non-existant.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True: Region is valid</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_region(self, region: str) -&gt; bool:
    &#34;&#34;&#34;
    A wrapper function for is_valid_region() that conducts an
    exit if the region is non-existant.

    Returns:
        bool: True: Region is valid
    &#34;&#34;&#34;  # noqa
    if not self.is_valid_region(region):
        raise PyForks.exceptions.InvalidRegion(
            msg=f&#34;[!] {region} is not a valid Trailforks Region.&#34;
        )
    return True</code></pre>
</details>
</dd>
<dt id="PyForks.region.Region.get_all_region_ridelogs"><code class="name flex">
<span>def <span class="ident">get_all_region_ridelogs</span></span>(<span>self, region: str, pages=1) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Downloads all of the trail ridelogs since the beginning of the
trails existence and stores the results in CSV format on the
local disk. Ideally, this should be handled by the Trailforks API but,
they've not provisioning access at this point (<a href="https://www.trailforks.com/about/api">https://www.trailforks.com/about/api</a>)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>region</code></strong> :&ensp;<code>str</code></dt>
<dd>region name as is shows on a URI</dd>
</dl>
<p>pages(int): The number of pages (HTML) to enumerate 1page == ~100 rides</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Pandas DataFrame(columns=[note,created,location_name,location_id,year,device_name,username])</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@authentication
def get_all_region_ridelogs(self, region: str, pages=1) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Downloads all of the trail ridelogs since the beginning of the
    trails existence and stores the results in CSV format on the
    local disk. Ideally, this should be handled by the Trailforks API but,
    they&#39;ve not provisioning access at this point (https://www.trailforks.com/about/api)

    Args:
        region (str): region name as is shows on a URI
        pages(int): The number of pages (HTML) to enumerate 1page == ~100 rides

    Returns:
        bool: Pandas DataFrame(columns=[note,created,location_name,location_id,year,device_name,username])
    &#34;&#34;&#34;  # noqa
    self.check_region(region)
    def get_date_string(row) -&gt; int:
        epoch = float(row[&#34;created&#34;])
        date = datetime.fromtimestamp(epoch).strftime(&#34;%m/%d/%Y&#34;)
        return date

    rows_per_pull = 100
    page_number = 0
    fields = self.uri_encode(&#34;note,created,location_name,location_id,year,device_name,username&#34;)
    region_id = self.get_region_id_by_alias(region)
    region_filter = self.uri_encode(f&#34;::{region_id}&#34;)
    dfs = []

    for i in range(0,pages):
        uri = f&#34;https://www.trailforks.com/api/1/ridelogs?fields={fields}&amp;filter=rid{region_filter}&amp;rows={rows_per_pull}&amp;page={page_number}&amp;order=desc&amp;sort=created&amp;app_id={self.app_id}&amp;app_secret={self.app_secret}&#34;
        json_response = self.make_trailforks_request(uri)
        dfs.append(pd.json_normalize(json_response))
        page_number += 1
    
    final_df = pd.concat(dfs, ignore_index=True)
    final_df[&#34;date&#34;] = final_df.apply(get_date_string, axis=1)
    return final_df</code></pre>
</details>
</dd>
<dt id="PyForks.region.Region.get_all_region_trails"><code class="name flex">
<span>def <span class="ident">get_all_region_trails</span></span>(<span>self, region: str) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Queries the Trailforks Trails API to obtain trail information for
a given region</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>region</code></strong> :&ensp;<code>str</code></dt>
<dd>region uri name (alias)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>Pandas DataFrame(columns=[created,title,difficulty,physical_rating,total_jumps,total_poi,alias,faved,stats])</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@authentication
def get_all_region_trails(self, region: str) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Queries the Trailforks Trails API to obtain trail information for
    a given region

    Args:
        region (str): region uri name (alias)

    Returns:
        pd.DataFrame: Pandas DataFrame(columns=[created,title,difficulty,physical_rating,total_jumps,total_poi,alias,faved,stats])
    &#34;&#34;&#34;
     # noqa
    self.check_region(region)
    fields = self.uri_encode(&#34;created,title,difficulty,physical_rating,total_jumps,total_poi,alias,faved,stats&#34;)
    region_id = self.get_region_id_by_alias(region)
    region_filter = self.uri_encode(f&#34;rid::{region_id}&#34;)
    rows = 100
    uri = f&#34;https://www.trailforks.com/api/1/trails?scope=full&amp;fields={fields}&amp;filter={region_filter}&amp;rows={rows}&amp;app_id={self.app_id}&amp;app_secret={self.app_secret}&#34;
    json_response = self.make_trailforks_request(uri)
    df = pd.json_normalize(json_response)
    return df</code></pre>
</details>
</dd>
<dt id="PyForks.region.Region.get_all_trailforks_regions"><code class="name flex">
<span>def <span class="ident">get_all_trailforks_regions</span></span>(<span>self, number_of_regions=40000) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve all known regions listed on Trailforks or a subset of regions
subject to the number_of_regions parameter</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>number_of_regions</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of regions to pull. Defaults to 40_000 and the minimum is 500.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>DataFrame(columns=['rid', 'title', 'alias'])</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@authentication
def get_all_trailforks_regions(self, number_of_regions=40_000) -&gt; pd.DataFrame: 
    &#34;&#34;&#34;
    Retrieve all known regions listed on Trailforks or a subset of regions
    subject to the number_of_regions parameter

    Args:
        number_of_regions (int, optional): Number of regions to pull. Defaults to 40_000 and the minimum is 500.

    Returns:
        pd.DataFrame: DataFrame(columns=[&#39;rid&#39;, &#39;title&#39;, &#39;alias&#39;])
    &#34;&#34;&#34;
     # noqa
    enumerated_results = 0
    page_number = 0
    results_per_page = 500
    fields = self.uri_encode(&#34;rid,title,alias&#34;)
    dfs = []

    pbar = tqdm(total=number_of_regions)
    while enumerated_results &lt;= number_of_regions:
        uri = f&#34;https://www.trailforks.com/api/1/regions?scope=basic&amp;app_id={self.app_id}&amp;fields={fields}&amp;app_secret={self.app_secret}&amp;rows={results_per_page}&amp;page={page_number}&#34;
        json_response = self.make_trailforks_request(uri)
        dfs.append(pd.json_normalize(json_response))
        page_number += 1
        enumerated_results += results_per_page
        pbar.update(results_per_page)
    pbar.close()
    final_df = pd.concat(dfs)
    final_df.astype(str).drop_duplicates(inplace=True)
    return final_df</code></pre>
</details>
</dd>
<dt id="PyForks.region.Region.get_region_id_by_alias"><code class="name flex">
<span>def <span class="ident">get_region_id_by_alias</span></span>(<span>self, region_alias: str) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Given a region alias (the URI name of the region), obtain the region
id (int) and return it</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>region_alias</code></strong> :&ensp;<code>str</code></dt>
<dd>URI name of the region</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Trailforks Region ID</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_region_id_by_alias(self, region_alias: str) -&gt; int:
    &#34;&#34;&#34;
    Given a region alias (the URI name of the region), obtain the region
    id (int) and return it

    Args:
        region_alias (str): URI name of the region

    Returns:
        int: Trailforks Region ID
    &#34;&#34;&#34;
    df = pd.read_parquet(self.region_data_file, engine=&#34;pyarrow&#34;)
    region_id = df.loc[df[&#34;alias&#34;] == region_alias, &#39;rid&#39;].item()
    return region_id</code></pre>
</details>
</dd>
<dt id="PyForks.region.Region.get_region_info"><code class="name flex">
<span>def <span class="ident">get_region_info</span></span>(<span>self, region: str) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Pulls region specific metrics from the region page. This whole function
is an abomination (I know) but, until Trailforks publishes an API I do
not see another way around this.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>region</code></strong> :&ensp;<code>str</code></dt>
<dd>region name as is shows on a URI</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>{
region_title:
string,
total_ridelogs:
int,
total_trails:
int,
total_distance:
float,
total_descent:
float,
highest_trailhead:
float,
reports:
int,
photos:
int,
ridden:
int,
country:
string,
state_province:
string,
city:
string,
links:
list,
favorites:
int,
rating:
int,
region_created
int</dd>
</dl>
<p>}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@authentication
def get_region_info(self, region: str) -&gt; dict:
    &#34;&#34;&#34;
    Pulls region specific metrics from the region page. This whole function
    is an abomination (I know) but, until Trailforks publishes an API I do
    not see another way around this.

    Args:
        region (str): region name as is shows on a URI

    Returns:
        dict: {
            region_title:       string,
            total_ridelogs:     int,
            total_trails:       int,
            total_distance:     float,
            total_descent:      float,
            highest_trailhead:  float,
            reports:            int,
            photos:             int,
            ridden:             int,
            country:            string,
            state_province:     string,
            city:               string,
            links:              list,
            favorites:          int,
            rating:             int,
            region_created      int
        }
    &#34;&#34;&#34;  # noqa
    self.check_region(region)
    region_id = self.get_region_id_by_alias(region)
    uri = f&#34;https://www.trailforks.com/api/1/region?id={region_id}&amp;scope=detailed&amp;app_id={self.app_id}&amp;app_secret={self.app_secret}&#34;
    json_response = self.make_trailforks_request(uri)

    region_info = {
        &#34;region_title&#34;: json_response[&#34;title&#34;],
        &#34;total_ridelogs&#34;: json_response[&#34;total_ridelogs&#34;],
        &#34;total_trails&#34;: json_response[&#34;total_trails&#34;],
        &#34;total_distance&#34;: self.meters_to_miles(json_response[&#34;total_distance&#34;]),
        &#34;total_descent&#34;: self.meters_to_miles(json_response[&#34;total_descent_distance&#34;]),
        &#34;highest_trailhead&#34;: self.meters_to_miles(json_response[&#34;highest_trailhead&#34;]),
        &#34;reports&#34;: json_response[&#34;total_reports&#34;],
        &#34;photos&#34;: json_response[&#34;total_photos&#34;],
        &#34;ridden&#34;: json_response[&#34;ridden&#34;],
        &#34;country&#34;: json_response[&#34;country_title&#34;],
        &#34;state_province&#34;: json_response[&#34;prov_title&#34;],
        &#34;city&#34;: json_response[&#34;city_title&#34;],
        &#34;links&#34;: json_response[&#34;links&#34;],
        &#34;favorites&#34;: json_response[&#34;faved&#34;],
        &#34;rating&#34;: json_response[&#34;rating&#34;],
        &#34;region_created&#34;: json_response[&#34;created&#34;]
    }
    return region_info</code></pre>
</details>
</dd>
<dt id="PyForks.region.Region.get_region_ridecounts"><code class="name flex">
<span>def <span class="ident">get_region_ridecounts</span></span>(<span>self, region: str) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a dataframe that contains that year-month-day and the
number of rides associated with that day.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>region</code></strong> :&ensp;<code>str</code></dt>
<dd>URI name of the region</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>pd.DataFrame(columns=["date","rides"])</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@authentication
def get_region_ridecounts(self, region: str) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Creates a dataframe that contains that year-month-day and the
    number of rides associated with that day.

    Args:
        region (str): URI name of the region

    Returns:
        pd.DataFrame: pd.DataFrame(columns=[&#34;date&#34;,&#34;rides&#34;])
    &#34;&#34;&#34; # noqa
    self.check_region(region)
    rows_per_pull = 500
    page_number = 0
    enumerated_results = 0
    fields = self.uri_encode(&#34;created&#34;)
    region_id = self.get_region_id_by_alias(region)
    region_info = self.get_region_info(region)
    total_ridelogs = int(region_info[&#34;ridden&#34;])
    region_filter = self.uri_encode(f&#34;::{region_id}&#34;)
    dfs = []

    while enumerated_results &lt; total_ridelogs:
        uri = f&#34;https://www.trailforks.com/api/1/ridelogs?fields={fields}&amp;filter=rid{region_filter}&amp;rows={rows_per_pull}&amp;page={page_number}&amp;order=desc&amp;sort=created&amp;app_id={self.app_id}&amp;app_secret={self.app_secret}&#34;
        json_response = self.make_trailforks_request(uri)
        dfs.append(pd.json_normalize(json_response))
        page_number += 1
        enumerated_results += rows_per_pull

    df = pd.concat(dfs, ignore_index=True)
    df[&#34;date&#34;] = pd.to_datetime(df[&#39;created&#39;],unit=&#34;s&#34;).dt.strftime(&#34;%Y-%m-%d&#34;)
    t_df = df.groupby([&#39;date&#39;], sort=False)[&#39;date&#39;].count().sort_index(ascending=False).reset_index(name=&#34;rides&#34;)
    return self.__enrich_ridecounts(t_df)</code></pre>
</details>
</dd>
<dt id="PyForks.region.Region.is_valid_region"><code class="name flex">
<span>def <span class="ident">is_valid_region</span></span>(<span>self, region: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check to make sure a region name is a real region by
making sure the page title is not Error</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True:is an existing region;False:region does not exist.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_valid_region(self, region: str) -&gt; bool:
    &#34;&#34;&#34;
    Check to make sure a region name is a real region by
    making sure the page title is not Error

    Returns:
        bool: True:is an existing region;False:region does not exist.
    &#34;&#34;&#34;  # noqa
    filter = self.uri_encode(f&#34;alias::{region}&#34;)
    uri = f&#34;https://www.trailforks.com/api/1/regions?filter={filter}&amp;app_id={self.app_id}&amp;app_secret={self.app_secret}&#34;
    json_response = self.make_trailforks_request(uri)
    if len(json_response) == 0:
        return False
    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="PyForks.trailforks.Trailforks" href="trailforks.html#PyForks.trailforks.Trailforks">Trailforks</a></b></code>:
<ul class="hlist">
<li><code><a title="PyForks.trailforks.Trailforks.distance_string_to_miles_float" href="trailforks.html#PyForks.trailforks.Trailforks.distance_string_to_miles_float">distance_string_to_miles_float</a></code></li>
<li><code><a title="PyForks.trailforks.Trailforks.feet_to_miles" href="trailforks.html#PyForks.trailforks.Trailforks.feet_to_miles">feet_to_miles</a></code></li>
<li><code><a title="PyForks.trailforks.Trailforks.has_numbers" href="trailforks.html#PyForks.trailforks.Trailforks.has_numbers">has_numbers</a></code></li>
<li><code><a title="PyForks.trailforks.Trailforks.make_trailforks_request" href="trailforks.html#PyForks.trailforks.Trailforks.make_trailforks_request">make_trailforks_request</a></code></li>
<li><code><a title="PyForks.trailforks.Trailforks.meters_to_miles" href="trailforks.html#PyForks.trailforks.Trailforks.meters_to_miles">meters_to_miles</a></code></li>
<li><code><a title="PyForks.trailforks.Trailforks.uri_encode" href="trailforks.html#PyForks.trailforks.Trailforks.uri_encode">uri_encode</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<center><img src="PyForks.png" width="60%"/></center>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="PyForks" href="index.html">PyForks</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="PyForks.region.Region" href="#PyForks.region.Region">Region</a></code></h4>
<ul class="">
<li><code><a title="PyForks.region.Region.check_region" href="#PyForks.region.Region.check_region">check_region</a></code></li>
<li><code><a title="PyForks.region.Region.get_all_region_ridelogs" href="#PyForks.region.Region.get_all_region_ridelogs">get_all_region_ridelogs</a></code></li>
<li><code><a title="PyForks.region.Region.get_all_region_trails" href="#PyForks.region.Region.get_all_region_trails">get_all_region_trails</a></code></li>
<li><code><a title="PyForks.region.Region.get_all_trailforks_regions" href="#PyForks.region.Region.get_all_trailforks_regions">get_all_trailforks_regions</a></code></li>
<li><code><a title="PyForks.region.Region.get_region_id_by_alias" href="#PyForks.region.Region.get_region_id_by_alias">get_region_id_by_alias</a></code></li>
<li><code><a title="PyForks.region.Region.get_region_info" href="#PyForks.region.Region.get_region_info">get_region_info</a></code></li>
<li><code><a title="PyForks.region.Region.get_region_ridecounts" href="#PyForks.region.Region.get_region_ridecounts">get_region_ridecounts</a></code></li>
<li><code><a title="PyForks.region.Region.is_valid_region" href="#PyForks.region.Region.is_valid_region">is_valid_region</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>